---
title: "DNAm_dataprep"
author: "Sarah Hatzenbuheler"
date: "6 9 2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

### TCGA DNAm data preparation


# Packages

```{r}
# specify packages and load them
packages <- c("TCGAbiolinks", "SummarizedExperiment", "IlluminaHumanMethylation450kanno.ilmn12.hg19", "minfi")
library("TCGAbiolinks")
library("SummarizedExperiment")
library("IlluminaHumanMethylation450kanno.ilmn12.hg19")
library("minfi")
library(PCAtools)
library(ChAMP)

# set directory
setwd("~/Studium/Master/Systems Biology Maastricht/Thesis/R")
```

## Data download

```{r}
# specify data to download 
TCGAbiolinks:::getProjectSummary("TCGA-GBM") # available data types
query_DNAm <- GDCquery(project = "TCGA-GBM",
                           data.category = "DNA methylation",
                           platform = "Illumina Human Methylation 450", 
                           legacy = TRUE)

# summary of query
query_res <- getResults(query_DNAm)
colnames(query_res)

# Data download
GDCdownload(query_DNAm, method = "api", files.per.chunk = 10)
data.DNAm <- GDCprepare(query_DNAm)

# saving data
# Save the data as a file, if you need it later, you can just load this file
# instead of having to run the whole pipeline again
saveRDS(object = data.DNAm,
        file = "DNAm_data.RDS",
        compress = FALSE)

# to re-access:
# data.DNAm <- readRDS(file = "DNAm_data.RDS")
# data.DNAm <- readRDS(file.choose()) # in case the above doesnt work
```

```{r}
# load data
data.DNAm <- readRDS(file = "DNAm_data.RDS")
```

## Preprocessing

```{r}
# access information of summarizedExperiment object
# gbm subtype information from:doi:10.1016/j.cell.2015.12.028
dim(data.DNAm)
colnames(colData(data.DNAm))
table(data.DNAm@colData$vital_status)
table(data.DNAm@colData$gender)
table(data.DNAm@colData$race)

# looking at the data
#head(assay(data.DNAm,))
#rowRanges(data.DNAm)
```

# Filtering
From here on the actually used code in this chunk

```{r}
# transforming DNAm data into matrix
met <- as.data.frame(SummarizedExperiment::assay(data.DNAm))
# same with clinical data
clinical <- data.frame(data.DNAm@colData)
```

Step 1: Filtering for NA

```{r}
## Step 1: remove probes with NA
probe.na <- rowSums(is.na(met))
table(probe.na == 0)
# chose those has not NA values in rows
probe <- probe.na[probe.na == 0]
met1 <- met[row.names(met) %in% names(probe), ]
any(is.na(met1))

# check vale range, should be between 0 and 1 - it is
range(met1)
```

Step 2: Filtering out patients with "wrong" tissue type 
(as well as the two patients with too much meta data missing, selected by missing sex)

```{r}
## Step 2: Filter out normal tissue patients and recurrent tumours && filter for sex == NA
index <- which(clinical$sample_type_id == "01" & !is.na(clinical$gender))
met2 <- met1[, index]
clinical2 <- clinical[index, ]
```

Step 3: Filter out probes on Sex chromosomes

```{r}
#keep <- !(row.names(met2) %in% ranges(data.DNAm)[seqnames(data.DNAm)$values %in% c("chrX","chrY")])
```

# Visualisation Pre-Norm
 MDS = multidimensional scaling, visual representation of dissimilarities or distances between sets of objects4
 
  - mdsPlot (Multidimensional Scaling Plot): This plot allows a visualization of the similarity of samples based on the     top 1000 most variable probes amongst all samples. Samples are colored by Sample Groups in this plot.
  - densityPlot: The beta distributions for each sample; users may use this figure to find samples which deviate            significantly from others and which may not be of good quality (e.g. incomplete bisulfite conversion). NB: It also        serves to identify and confirm methylated or unmethylated control samples, if these were included in the study).
  - dendrogram: The clustering plot for all samples, you may select different method to generate this plot. There is a      parameter Feature.sel="None" in champ.QC() function. While “None” means the distance between samples would be calculated     directly by all probes (your server may crash if you directly do this on a large data set), “SVD” means champ.QC()        function would use SVD method to do deconvolute on beta matrix, then select significant components based only             EstDimRMT() method from “isva” package. Then the distance between samples would be calculated based on these            components.

```{r}
# changing dataformat to matrix for analysis
met_mat <- as.matrix(as.data.frame(met2))

# setting directory again (as it seems to be constantly changed -.-)
setwd("~/Studium/Master/Systems Biology Maastricht/Thesis/R")
# cisualisation of density, MDS, and dendrogram plots prenormalisation
champ.QC(met_mat, clinical2$tissue_or_organ_of_origin)
champ.QC(met_mat, clinical2$gender)
champ.QC(met_mat, clinical2$race, Feature.sel="SVD")
```
## Normalisation

Using BMIQ method

```{r}
# normalise using BMIQ normalisation
met_normBMIQ <- champ.norm(beta=met_mat, resultsDir="./CHAMP_Normalization/", 
                       method="BMIQ", plotBMIQ=F, arraytype="450K", cores=4)
met_normBMIQ <- as.matrix(as.data.frame(met_normBMIQ))
```
saving / retrieving data from normalisation

```{r}
#save matrix because of processing time
write.table(met_normBMIQ, file="met_normBMIQ.txt", row.names=T, col.names=T)
# read it back in
met_normBMIQ = read.table("met_normBMIQ.txt", check.names=FALSE)
met_normBMIQ <- as.matrix(as.data.frame(met_normBMIQ))
```

PBC method not to be used
```{r}
# using PBC method
met_normPBC <- champ.norm(beta=met_mat, resultsDir="./CHAMP_Normalization/", 
                          method="PBC", plotBMIQ=FALSE, arraytype="450K", cores=4)
```

Future Steps - TBD

```{r}
## QC check: predict sex based on met values
library(wateRmelon)
predictedSex <- predictSex(met_mat)# needs normalising first, uses PCA 

## step 2: remove probes that match to chromosome  X and Y 
# get illumina 450k annotation data
#ann450k <- getAnnotation(IlluminaHumanMethylation450kanno.ilmn12.hg19)
#keep <- !(row.names(met1) %in% ann450k$Name[ann450k$chr %in% c("chrX","chrY")])
#table(keep)
#met2 <- met1[keep, ]
```

### Visualisation stuff

Obviously samples seem not to have been normalised yet (See boxplots and density curves).

```{r}
### Pre Normalisation
# Density plot
densityPlot(met_mat, main = "Before Normalisation")

#met_grs <- makeGenomicRatioSetFromMatrix(met_mat)

# Boxplots
boxplot(met_mat, xlab = "Patients", ylab = "beta", las = 2, main = "Before normalisation") # needs fixing the xlabels
```
```{r}
# After normalisation with ChAMPS
densityPlot(met_normBMIQ, main = "Normalisation BMIQ")
densityPlot(met_normPBC, main = "Normalisation PBC")

boxplot(met_normPBC, xlab = "Patients", ylab = "beta", las = 2, main = "Normalisation PBC")
boxplot(met_normBMIQ, xlab = "Patients", ylab = "beta", las = 2, main = "Normalisation BMIQ")
```

## PCA

```{r}
# Create PCA project
project.pca <- prcomp(t(met_mat))
#summary(project.pca)

#Determine the proportion of variance of each component
#Proportion of variance equals (PC stdev^2) / (sum all PCs stdev^2)
project.pca.proportionvariances <- ((project.pca$sdev^2) / (sum(project.pca$sdev^2)))*100

# Bar plot (or Scree Plot)
barplot(project.pca.proportionvariances, cex.names=1, xlab=paste("Principal component (PC), 1-", length(project.pca$sdev)), ylab="Proportion of variation (%)", main="Scree plot", ylim=c(0,20))
```


```{r}
# Sex differences PCA
# define groups to colour for
group_sex <- NA
group_sex[clinical2$gender  == "male"] <- 1
group_sex[clinical2$gender  == "female"] <- 2

# Biplots of the first 10 PCs
par(cex=1.0, cex.axis=0.8, cex.main=0.8, xpd = TRUE)
pairs(project.pca$x[,1:5], col = c("red", "cornflowerblue")[group_sex], 
      main="Principal components analysis bi-plot\nPCs 1-5 coloured by sex (Pre-Normalisation)", pch=16)
legend("bottomright", fill = c("red", "cornflowerblue"), legend = c("male", "female"))
pairs(project.pca$x[,6:10], col = c("red", "cornflowerblue")[group_sex], 
      main="Principal components analysis bi-plot\nPCs 6-10 coloured by sex(Pre-Normalisation)", pch=16)
```

```{r}
# Tissue differences PCA
# define groups to colour for
group_local <- NA
group_local[clinical2$tissue_or_organ_of_origin  == "Brain, NOS"] <- 1
group_local[clinical2$tissue_or_organ_of_origin  == "Temporal lobe"] <- 2
group_local[clinical2$tissue_or_organ_of_origin  == "Frontal lobe"] <- 3
group_local[clinical2$tissue_or_organ_of_origin  == "Occipital lobe"] <- 4
group_local[clinical2$tissue_or_organ_of_origin  == "Overlapping lesion of brain"] <- 5

# Biplots of the first 10 PCs
par(cex=1.0, cex.axis=0.8, cex.main=0.8, xpd = T)
pairs(project.pca$x[,1:5], col = c("red", "cornflowerblue", "purple", "yellow", "black")[group_local], 
      main="Principal components analysis bi-plot\nPCs 1-5 coloured by sample origin (Pre-Normalisation)", pch=16)
legend(0.05, 0.02, fill = c("red", "cornflowerblue", "purple", "yellow", "black"), 
        legend = unique(clinical2$tissue_or_organ_of_origin), ncol = 5, text.width = 0.15, cex = 0.7, x.intersp = 0.2)
pairs(project.pca$x[,6:10], col = c("red", "cornflowerblue", "purple", "yellow", "black")[group_local], 
      main="Principal components analysis bi-plot\nPCs 6-10 coloured by sample origin (Pre-Normalisation)", pch=16)
```

```{r}
# Race differences PCA
# define groups to colour for
group_race <- NA
group_race[clinical2$race  == "not reported"] <- 1
group_race[clinical2$race  == "white"] <- 2
group_race[clinical2$race  == "black or african american"] <- 3

# Biplots of the first 10 PCs
par(cex=1.0, cex.axis=0.8, cex.main=0.8, xpd = TRUE)
pairs(project.pca$x[,1:5], col = c("red", "cornflowerblue", "black")[group_race], 
      main="Principal components analysis bi-plot\nPCs 1-5 coloured by race (Pre-Normalisation)", pch=16)
legend(0.05, 0.03, fill = c("red", "cornflowerblue", "black"), legend = unique(clinical2$race), 
       ncol = 3, cex = 0.8)
par(cex=1.0, cex.axis=0.8, cex.main=0.8, xpd = TRUE)
pairs(project.pca$x[,6:10], col = c("red", "cornflowerblue", "black")[group_race], 
      main="Principal components analysis bi-plot\nPCs 6-10 coloured by race(Pre-Normalisation)", pch=16)
legend(0.05, 0.03, fill = c("red", "cornflowerblue", "black"), legend = unique(clinical2$race), 
       ncol = 3, cex = 0.8)

# repeat for age? (in levele? how?)
```


```{r}
# Triplots --> sort this out?
require(scatterplot3d)
par(mar=c(4,4,4,4), cex=1.0, cex.main=0.8, cex.axis=0.8)

scatterplot3d(project.pca$x[,1:3], angle=-40, main="", color="black", pch=17, xlab=paste("PC1, ", round(project.pca.proportionvariances[1], 2), "%"), ylab=paste("PC2, ", round(project.pca.proportionvariances[2], 2), "%"), zlab=paste("PC3, ", round(project.pca.proportionvariances[3], 2), "%"), grid=FALSE, box=FALSE)
source('http://www.sthda.com/sthda/RDoc/functions/addgrids3d.r')
addgrids3d(project.pca$x[,1:3], grid = c("xy", "xz", "yz"))

source('http://www.sthda.com/sthda/RDoc/functions/addgrids3d.r')
addgrids3d(project.pca$x[,1:3], grid = c("xy", "xz", "yz"))
```


