---
title: "Deconvolution Methylation data - MeDeCom"
author: "Sarah Hatzenbuehler"
date: "26 11 2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#### Non-negative Matrix Factorisation based on Lutsik et al. (2016): MeDeCom


# Packages

```{r}
library(devtools)
#devtools::install_github("lutsik/MeDeCom",ref="windows")
#devtools::install_github("rlbarter/superheat")
library(MeDeCom)
library(superheat)
library(ggplot2)
library(VennDiagram)
library(clusterProfiler)
library(org.Hs.eg.db)
```

## Loading in data

After preprocessing the raw methylation data, we extracted a matrix of beta values after some filtering based on feature selection. Multiple FS criteria have been applied, and in the next steps have been used in the NMF experiments.
FS criteria: 
1) variance based
2) biologically motivated on base on published gene lists (Teo et al. 2019, Wang et al. 2017, Neftel et al. 2019, Gaska et al 2021)
3) random gene list as comparison

```{r}
#load in example data
data(example.dataset, package="MeDeCom")

# randomly select features to see if results still show same patterns
rand_idx <- sample(1:dim(D)[1], 1500)
beta_mat <- D[rand_idx, ]
```
```{r}
# load beta matrix from preprocessed data
# for preprocessed data based on biologically relevant gene lsit: _teo, _wang, _neftel, 
# _random, _wero150, _overlap
setwd("C:/Users/Sarah/Documents/Studium/Master/Systems Biology Maastricht/Thesis/R")
beta_mat <- as.matrix(read.table(file = "beta_preprocessed_var_black.txt"))
```

## Running Deconvolution
 
Before running the deconvolution, it is important to think about a number of parameters.
Ks : number range of cell types included in the mix
lambdas : range of regularisation parameter, with 0 there being no regularisation. Lambda basically restricts any possible beta values to be between 0 and 1, thus confirming closer to biology.
NINIT : number of random initialisations
NFOLDS : number of crossvalisation folds
NCORES: number of CPU cores the decon is running on
(for example numbers check the vignette: https://github.com/lutsik/MeDeCom/blob/master/vignettes/MeDeCom.md)

According to Weronicka's thesis: optimal NINIt for RNAseq = 30-50

```{r}
# Running medecom decon
medecom.result<-runMeDeCom(beta_mat, 2:10, c(0,10^(-5:-1)), NINIT=10, 
                           NFOLDS=10, ITERMAX=300, NCORES=5)

# save result
setwd("C:/Users/Sarah/Documents/Studium/Master/Systems Biology Maastricht/Thesis/R")
saveRDS(object = medecom.result, file = "Medecom_result_example.RDS", compress = FALSE)
```

### Result analysis

## Loading in all results
```{r}
# Reload results after saving
setwd("~/Studium/Master/Systems Biology Maastricht/Thesis/R")
medecom.result.teo <- readRDS("Medecom_result_teo.RDS")
medecom.result.var <- readRDS("Medecom_result_var.RDS")
medecom.result.wang <- readRDS("Medecom_result_wang.RDS")
medecom.result.neftel <- readRDS("Medecom_result_neftel.RDS")
medecom.result.random <- readRDS("Medecom_result_random.RDS")
medecom.result.wero <- readRDS("Medecom_result_wero150.RDS")
medecom.result.overlap <- readRDS("Medecom_result_overlap.RDS")

# also reload the beta matrices for MDS plot later
beta_mat.teo <- as.matrix(read.table(file = "beta_preprocessed_teo.txt"))
beta_mat.var <- as.matrix(read.table(file = "beta_preprocessed_var.txt"))
beta_mat.wang <- as.matrix(read.table(file = "beta_preprocessed_wang.txt"))
beta_mat.neftel <- as.matrix(read.table(file = "beta_preprocessed_neftel.txt"))
beta_mat.random <- as.matrix(read.table(file = "beta_preprocessed_random.txt"))
beta_mat.wero <- as.matrix(read.table(file = "beta_preprocessed_wero150.txt"))
beta_mat.overlap <- as.matrix(read.table(file = "beta_preprocessed_overlap.txt"))
```

## Visualisation 

# Error measures for different lambda settings

To select optimal hyperparameters, we have a look at error curves for differing lambda and number of LMCs (k). Generally, we aim to take values in the "elbow" of the curve, as this is normally a good trade-off value regarding accuracy and bias. In our case, we aim to take the highest lambda giving us the lowest CV error, at a value for k which is the lowest before a more steady drop in CV error.
Having selected both parameters, we can anaylse the results more in depth using both of them.

```{r}
# visualise CV error for different lambda
plotParameters(medecom.result.teo)#, statistic = "rmse")
plotParameters(medecom.result.var)
plotParameters(medecom.result.wang)
plotParameters(medecom.result.neftel)
plotParameters(medecom.result.random)
plotParameters(medecom.result.wero)
plotParameters(medecom.result.overlap)
```
To select optimal lambda for different k, a different visualisation can be employed:
```{r}
# line plot for set k
plotParameters(medecom.result.teo, K=4, lambdaScale="log")
plotParameters(medecom.result.var, K=4, lambdaScale="log")
plotParameters(medecom.result.wang, K=4, lambdaScale="log")
plotParameters(medecom.result.neftel, K=4, lambdaScale="log")
plotParameters(medecom.result.random, K=4, lambdaScale="log")
plotParameters(medecom.result.wero, K=4, lambdaScale="log")
plotParameters(medecom.result.overlap, K=4, lambdaScale="log")
```
# Visualise LMC distribution for different lambda

Make histogramm of LMC profiles to visualise effect of lambda regularisation. Lambda closer to zero results in a value distribution closer to 0.5, whereas higher lambdas push the methylation values more towards 0 and 1. This is closer to what we would expect in more uniform celltypes, since this suggests a more conform status of being (un)methylated per probe for each subtype.
As example we only take the NMF results with FS based on Teo et al. for this.

```{r}
# get T matrices from the results
paras.teo <- medecom.result.teo@parameters   #change input here
output.teo <- medecom.result.teo@outputs     #change input here
output.teo <- output.teo$'1'
T.teo <- output.teo$'T'

# get LMC profiles for k = 4 and different lambda
k4 <- data.frame(lambda_0 = T.teo[[3]], lambda_1e05 = T.teo[[12]], lambda_1e04 = T.teo[[21]],
                 lambda_0.001 = T.teo[[30]], lambda_0.01 = T.teo[[39]], lambda_0.1 = T.teo[[48]])
```

```{r}
# make histogram
par(mfrow = c(1,3))
hist(as.matrix(k4[,1:4]), main = "lambda = 0", xlab = "beta values")
#hist(as.matrix(k4[,5:8]), main = "lambda = 1e-05", xlab = "beta values")
#hist(as.matrix(k4[,9:12]), main = "lambda = 1e-04", xlab = "beta values")
#hist(as.matrix(k4[,13:16]), main = "lambda = 0.001", xlab = "beta values")
hist(as.matrix(k4[,17:20]), main = "lambda = 0.01", xlab = "beta values")
hist(as.matrix(k4[,21:24]), main = "lambda = 0.1", xlab = "beta values")
#mtext("Beta value distribution of LMCs for different lambda", side = 3, line = -2, outer = T)
```
```{r}
# print for each individual LMC
par(mfrow = c(2,2))
hist(as.matrix(k4[,17]), main = "lambda = 0.01 for LMC1", xlab = "beta values")
hist(as.matrix(k4[,18]), main = "lambda = 0.01 for LMC2", xlab = "beta values")
hist(as.matrix(k4[,19]), main = "lambda = 0.01 for LMC3", xlab = "beta values")
hist(as.matrix(k4[,20]), main = "lambda = 0.01 for LMC4", xlab = "beta values")
```
```{r}
# Compare with the distribution of the original data
par(mfrow = c(1,2))
hist(beta_mat.teo, main = "beta values before NNMF (n = 98)\n filtered based on Teo et al.", xlab = "beta values", cex.main = 1) #change input here
hist(as.matrix(k4[,17:20]), main = "beta value distribution of LMCs (k = 4)\n for lambda = 0.01", 
     xlab = "beta values", cex.main = 1)
```

# Extractiong Latent Methylation components


```{r}
# extract LMCs for set lambda and K
lmcs<-getLMCs(medecom.result.teo, K=4, lambda=0.01)
str(lmcs)
```

## Visualisation of LMC relationships

# Dendrograms
Visualising the closeness of the extracted LMCs in form of dendrograms

```{r}
# dendrogram
plotLMCs(medecom.result.teo, K=4, lambda=0.01, type="dendrogram")
plotLMCs(medecom.result.var, K=4, lambda=0.01, type="dendrogram")
plotLMCs(medecom.result.wang, K=4, lambda=0.01, type="dendrogram")
plotLMCs(medecom.result.neftel, K=4, lambda=0.01, type="dendrogram")
plotLMCs(medecom.result.random, K=4, lambda=0.01, type="dendrogram")
plotLMCs(medecom.result.wero, K=4, lambda=0.01, type="dendrogram")
plotLMCs(medecom.result.overlap, K=4, lambda=0.01, type="dendrogram")
```

# MDS plots
To better view the different latent directions in the data represented by the LMCs, we plot them into MDS plots containing the original data. 

```{r}
# MDS plot with data included
plotLMCs(medecom.result.teo, K=4, lambda=0.01, type="MDS", D = beta_mat.teo)
plotLMCs(medecom.result.var, K=4, lambda=0.01, type="MDS", D = beta_mat.var)
plotLMCs(medecom.result.wang, K=4, lambda=0.01, type="MDS", D = beta_mat.wang)
plotLMCs(medecom.result.neftel, K=4, lambda=0.01, type="MDS", D = beta_mat.neftel)
plotLMCs(medecom.result.random, K=4, lambda=0.01, type="MDS", D = beta_mat.random)
plotLMCs(medecom.result.wero, K=4, lambda=0.01, type="MDS", D = beta_mat.wero)
plotLMCs(medecom.result.overlap, K=4, lambda=0.01, type="MDS", D = beta_mat.overlap)
```

# PCA plots
To better interpret the distribution of the data and the different directions of the LMCs, we project them into a PCA space of the first two PCs. For this, we multiply each LMC (which is kind of a profile including weights for all probes) with the weights, or loadings, of the PCA for the data they're based off. The results of this weighted sum or dot product gives us the coordinates of the LMC in the PCA space of the data (if done for both PC1 and 2 here)

```{r}
# get T matrices from the results
paras.teo <- medecom.result.random@parameters  #change input here
output.teo <- medecom.result.random@outputs    #change input here
output.teo <- output.teo$'1'
Tall.teo <- output.teo$'T'
T.teo <- as.data.frame(Tall.teo[[39]])
colnames(T.teo) <- c("LMC1", "LMC2", "LMC3", "LMC4")

# make PCA plots to put the LMCs in 
pca.teo <- prcomp(t(beta_mat.random))         #change input here
pred.lmc <- data.frame(matrix(ncol=4,nrow=4, 
                              dimnames=list(c("LMC1", "LMC2", "LMC3", "LMC4"),
                                            c("PC1", "PC2", "PC3", "PC4"))))
for (i in 1:dim(T.teo)[2]){
  pred.lmc[i,1] <- (T.teo[,i] - pca.teo$center) %*% pca.teo$rotation[,1]
  pred.lmc[i,2] <- (T.teo[,i] - pca.teo$center) %*% pca.teo$rotation[,2]
}
```
```{r}
plot(pca.teo$x[,1:2], xlim = c(min(pred.lmc[,1])-1, max(pred.lmc[,1]+1)), 
     ylim = c(min(pred.lmc[,2])-1, max(pred.lmc[,2]+2)), pch = 16, 
     main = "PCA of LMC projection filtered for random genes")
points(pred.lmc[,1:2], col = "red", pch = 16)
#text(pred.lmc, labels = rownames(pred.lmc), pos = 3)
text(pred.lmc[,1:2], labels = rownames(pred.lmc[index.random,]), pos = 3) # taken from after heatmaps
```

```{r}
# have a look at PC 3 and 4 to see the 4th LMC better
# create Coordniates for PC3 and 4 for LMCs
for (i in 1:dim(T.teo)[2]){
  pred.lmc[i,3] <- (T.teo[,i] - pca.teo$center) %*% pca.teo$rotation[,3]
  pred.lmc[i,4] <- (T.teo[,i] - pca.teo$center) %*% pca.teo$rotation[,4]
  #pred.lmc[i,5] <- (T.teo[,i] - pca.teo$center) %*% pca.teo$rotation[,5]
}
```
```{r}
# plot multiple PCA spaces
idx <- subset(expand.grid(x=1:4,y=1:4),x!=y)
i <-1
pairs(pca.teo$x[,1:4], pch=16, xlim = c(min(pred.lmc-1), max(pred.lmc+1)), 
      ylim = c(min(pred.lmc-1), max(pred.lmc+1)), 
            panel=function(x, y, ...) {
                points(x, y, pch=16, cex = 1.5)
                points(pred.lmc[,idx[i,"y"]],pred.lmc[,idx[i,"x"]],
                             cex=1.7,pch=16,col='red')
                text(pred.lmc[,idx[i,"y"]],pred.lmc[,idx[i,"x"]], 
                     labels = rownames(pred.lmc[index.random,]), pos = 3)
                     #labels = rownames(pred.lmc), pos = 3)
                i <<- i +1},
      main = "PCA of LMC projection filtered for random genes"
            )
```


## Visualise and compare LMC proportions between different FS selections

To compare NMF results for different FS prior to it, we visualise the resulting LMC proportions per subject in the form of barplots. Since in the outcome, LMCs are not consistently labelled throughout all different results, we also compare the euclidean distance among different proportion profiles to find matching ones.

```{r}
# create color palette:
library(RColorBrewer)
coul <- brewer.pal(4, "Set1") 

#create stacked bar plots of proportions
prop.teo <- getProportions(medecom.result.teo, K=4, lambda=0.01)
prop.var <- getProportions(medecom.result.var, K=4, lambda=0.01)
prop.wang <- getProportions(medecom.result.wang, K=4, lambda=0.01)
prop.neftel <- getProportions(medecom.result.neftel, K=4, lambda=0.01)
prop.random <- getProportions(medecom.result.random, K=4, lambda=0.01)
prop.wero <- getProportions(medecom.result.wero, K=4, lambda=0.01)
prop.overlap <- getProportions(medecom.result.overlap, K=4, lambda=0.01)

# Transform this data in %
data_percentage.teo <- apply(prop.teo, 2, function(x){x*100/sum(x,na.rm=T)})
data_percentage.var <- apply(prop.var, 2, function(x){x*100/sum(x,na.rm=T)})
data_percentage.wang <- apply(prop.wang, 2, function(x){x*100/sum(x,na.rm=T)})
data_percentage.neftel <- apply(prop.neftel, 2, function(x){x*100/sum(x,na.rm=T)})
data_percentage.random <- apply(prop.random, 2, function(x){x*100/sum(x,na.rm=T)})
data_percentage.wero <- apply(prop.wero, 2, function(x){x*100/sum(x,na.rm=T)})
data_percentage.overlap <- apply(prop.overlap, 2, function(x){x*100/sum(x,na.rm=T)})
 
# Make a stacked barplot
barplot(data_percentage.teo, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Teo 2019", 
        legend.text = rownames(data_percentage.teo))
barplot(data_percentage.var, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Variance")
barplot(data_percentage.wang, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Wang 2017")
barplot(data_percentage.neftel, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Neftel 2019")
barplot(data_percentage.random, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for random FS")
barplot(data_percentage.wero, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Gaska 2021")
barplot(data_percentage.overlap, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on minimal overlapping genes")
```

For better comparison, we are taking a look at the first three samples and try to establish which LMCs have similar proportions
```{r}
# Stacked barplots for first 5 samples
barplot(data_percentage.teo[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", main="cell type proportion for FS based on Teo 2019\nSamples 1-5")
barplot(data_percentage.var[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", main="cell type proportion for FS based on Variance\nSamples 1-5")
barplot(data_percentage.wang[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", main="cell type proportion for FS based on Wang 2017\nSamples 1-5")
barplot(data_percentage.neftel[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", 
        main="cell type proportion for FS based on Neftel 2019\nSamples 1-5")
barplot(data_percentage.random[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", main="cell type proportion for random FS\nSamples 1-5")
barplot(data_percentage.wero[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", main="cell type proportion for FS based on Gaska 2021\nSamples 1-5")
barplot(data_percentage.overlap[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", 
        main="cell type proportion for FS based on minimal overlap\nSamples 1-5")
```

To sort the LMCs according to most similar patterns across all FS, we correlate each LMC-row of one FS dataset with all rows of another. Best correlation is considered concordant LMC.
Another approach is to calculate the euclidean distance between rows of two data sets to find the best match.
```{r}
# Euclidean distance matrix
ref.teo <- prop.teo
rownames(ref.teo) <- c("Teo LMC1", "Teo LMC2", "Teo LMC3", "Teo LMC4")

dist.var <- as.matrix(dist(rbind(ref.teo, prop.var), method = "euclidean"))
dist.wang <- as.matrix(dist(rbind(ref.teo, prop.wang), method = "euclidean"))
dist.neftel <- as.matrix(dist(rbind(ref.teo, prop.neftel), method = "euclidean"))
dist.random <- as.matrix(dist(rbind(ref.teo, prop.random), method = "euclidean"))
dist.wero <- as.matrix(dist(rbind(ref.teo, prop.wero), method = "euclidean"))
dist.overlap <- as.matrix(dist(rbind(ref.teo, prop.overlap), method = "euclidean"))

# visualise
heatmap(dist.var, main = "Teo vs Variance - Euclidean Distance")
#heatmap(dist.var[1:4, 5:8]) # for single values
heatmap(dist.wang, main = "Teo vs Wang - Euclidean Distance")
heatmap(dist.neftel, main = "Teo vs Neftel - Euclidean Distance")
heatmap(dist.random, main = "Teo vs Random - Euclidean Distance")
heatmap(dist.wero, main = "Teo vs Gaska - Euclidean Distance")
heatmap(dist.overlap, main = "Teo vs overlap - Euclidean Distance")

# get vector of lowest distance to use for reordering
index.var <- unname(apply(dist.var[1:4, 5:8], 1, which.min))
index.wang <- unname(apply(dist.wang[1:4, 5:8], 1, which.min))
index.neftel <- unname(apply(dist.neftel[1:4, 5:8], 1, which.min))
index.random <- unname(apply(dist.random[1:4, 5:8], 1, which.min))
index.wero <- unname(apply(dist.wero[1:4, 5:8], 1, which.min))
index.overlap <- unname(apply(dist.overlap[1:4, 5:8], 1, which.min))
```

For better and clearer overview, we compile all distance measures into one heatmap

```{r}
# make all distance matrices into one
# rename proportion vectors
ref.var <- prop.var
rownames(ref.var) <- c("Var LMC1", "Var LMC2", "Var LMC3", "Var LMC4")
ref.wang <- prop.wang
rownames(ref.wang) <- c("Wang LMC1", "Wang LMC2", "Wang LMC3", "Wang LMC4")
ref.neftel <- prop.neftel
rownames(ref.neftel) <- c("Neftel LMC1", "Neftel LMC2", "Neftel LMC3", "Neftel LMC4")
ref.random <- prop.random
rownames(ref.random) <- c("Random LMC1", "Random LMC2", "Random LMC3", "Random LMC4")
ref.wero <- prop.wero
rownames(ref.wero) <- c("Gaska LMC1", "Gaska LMC2", "Gaska LMC3", "Gaska LMC4")
ref.overlap <- prop.overlap
rownames(ref.overlap) <- c("Overlap LMC1", "Overlap LMC2", "Overlap LMC3", "Overlap LMC4")

# make one distance matrix of all
dist.all <- as.matrix(dist(rbind(ref.teo, ref.var, ref.wang, ref.neftel, #ref.overlap, 
                                 ref.wero, ref.random), method = "euclidean"))
```
```{r}
# visualise
heatmap(dist.all, main = "Euclidean Distance between all LMC proportions")
heatmap.2(dist.all, main = "Euclidean Distance between all LMC proportions", 
          trace = "none", density.info = "none", margins =c(8,8))
```

Using the corresponding LMCs across different FS results, we reorganise the barplots to better compare proportions between the results, trying to match up most similar LMC proportions for all.

```{r}
# Try again with resorting the LMC rows to match Teo
data_percentage.var1 <- data_percentage.var[index.var, ]
data_percentage.wang1 <- data_percentage.wang[index.wang,]
data_percentage.neftel1 <- data_percentage.neftel[index.neftel,]
data_percentage.random1 <- data_percentage.random[index.random,]
data_percentage.wero1 <- data_percentage.wero[index.wero,]
data_percentage.overlap1 <- data_percentage.overlap[index.overlap,]

# plot to see difference
barplot(data_percentage.teo[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", main="cell type proportion for FS based on Teo 2019\nSamples 1-5")
barplot(data_percentage.var1[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", main="cell type proportion for FS based on Variance
        \nSamples 1-5 (reorganised)")
barplot(data_percentage.wang1[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", main="cell type proportion for FS based on Wang 2017
        \nSamples 1-5 (reorganised) ")
barplot(data_percentage.neftel1[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", 
        main="cell type proportion for FS based on Neftel 2019\nSamples 1-5 (reorganised)")
barplot(data_percentage.random1[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", 
        main="cell type proportion for random FS\nSamples 1-5 (reorganised)")
barplot(data_percentage.wero1[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", 
        main="cell type proportion for FS based on Gaska 2021\nSamples 1-5 (reorganised)")
barplot(data_percentage.overlap1[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", 
        main="cell type proportion for FS based on minimal overlap\nSamples 1-5 (reorganised)")
```
```{r}
# Now print all data again in a reorganised fashion
# Make a stacked barplot
barplot(data_percentage.teo, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Teo 2019")#, 
        #legend.text = rownames(data_percentage.teo))
barplot(data_percentage.var1, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Variance \n(reorganised)")
barplot(data_percentage.wang1, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Wang 2017 \n (reorganised)")
barplot(data_percentage.neftel1, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Neftel 2019 \n (reorganised)")
barplot(data_percentage.random1, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for random FS \n (reorganised)")
barplot(data_percentage.wero1, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Gaska 2021\n (reorganised)")
barplot(data_percentage.overlap1, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on minimal overlapping genes \n (reorganised)")
```

## Cross-checking with non-caucasian samples

```{r}
# load data in
setwd("~/Studium/Master/Systems Biology Maastricht/Thesis/R")
medecom.result.black_teo <- readRDS("Medecom_result_teo_black.RDS")
medecom.result.black_var <- readRDS("Medecom_result_var_black.RDS")

beta_mat.black_teo <- as.matrix(read.table(file = "beta_preprocessed_teo_black.txt"))
beta_mat.black_var <- as.matrix(read.table(file = "beta_preprocessed_var_black.txt"))
```

```{r}
# plot CV error curves for optimal k and lambda
plotParameters(medecom.result.black_teo)
plotParameters(medecom.result.black_var)
```
```{r}
# create proportion plots
prop.black_teo <- getProportions(medecom.result.black_teo, K=4, lambda=0.01)
prop.black_var <- getProportions(medecom.result.black_var, K=4, lambda=0.01)

data_percentage.black_teo <- apply(prop.black_teo, 2, function(x){x*100/sum(x,na.rm=T)})
data_percentage.black_var <- apply(prop.black_var, 2, function(x){x*100/sum(x,na.rm=T)})

# relate proportions to one another
ref.black_teo <- prop.black_teo
rownames(ref.black_teo) <- c("Black Teo LMC1", "Black Teo LMC2", "Black Teo LMC3", 
                             "Black Teo LMC4")
ref.black_var <- prop.black_var
rownames(ref.black_var) <- c("Black var LMC1", "Black var LMC2", "Black var LMC3", 
                             "Black var LMC4")
# Heatmap of distance between both black runs
dist.black <- as.matrix(dist(rbind(ref.black_teo, ref.black_var), method = "euclidean"))
heatmap(dist.black, main = "Black: Teo vs Variance - Euclidean Distance", margins = c(8,8))
```
```{r}
# cross check distance with previous experiments
dist.blackVsWhite <- as.matrix(dist(rbind(ref.black_teo, ref.black_var, ref.teo), 
                                    method = "euclidean"))
heatmap(dist.black, main = "Caucasian vs Black Americans - Euclidean Distance", margins = c(8,8))

# this wont work because of different matrix dimensions. But how to compare????
```


## Analysing similarities in Feature Selection prior to NNMF

To investigate how similar the criteria applied for feature selection have been, we check for common genes within the lists as well as functional similarities by means of KEGG enrichment clustering.

```{r}
# set directory
setwd("~/Studium/Master/Systems Biology Maastricht/Thesis/R")

# read in gene lists
genes_teo2019 <- unlist(read.csv(file = "Teo2019_genelist500.csv", header = F))
genes_wang2017 <- unlist(read.csv(file = "Wang2017_genelist_subtypes.csv", header = F))
genes_neftel2019 <- unlist(read.csv(file = "Neftel2019_genelist_subtypes.csv", header = F))
genes_wero150 <- unlist(read.csv(file = "Weronika_genelist_top50_geneID.csv", header = F))
genes_var <- unlist(read.csv(file = "var_genes_unique.csv", header = F))
genes_random <- unlist(read.csv(file = "random_gene_list.csv", header = F))
```

Here we check how many of the genes are overlapping in each gene list and display the results using Venn diagrams

```{r}
# make Venn diagram of gene overlap
VennDiagram::get.venn.partitions(list(genes_neftel2019 = genes_neftel2019, 
                                      genes_teo2019 = genes_teo2019, 
                                      genes_var = genes_var,
                                      genes_random = genes_random,
                                      genes_wang2017 = genes_wang2017,
                                      genes_wero150 = genes_wero150))
```

```{r}
# put all biological genes in one list
biol_genes <- unique(c(genes_neftel2019, genes_teo2019, genes_wang2017, genes_wero150))

# print Venn diagramm
grid.newpage()
grid::grid.draw(VennDiagram::venn.diagram(list(#"Biol. FS genes (944)" = biol_genes,
                                               "Neftel et al. (363)"= genes_neftel2019, 
                                               "Teo et al. (500)" = genes_teo2019, 
                                               #"Variance (3170)" = genes_var, 
                                               #"Random genes (200)" = genes_random,
                                               "Wang et al. (150)" = genes_wang2017,
                                               "Gaska (113)" = genes_wero150,
                                               NULL
                                               ),
                                          NULL))
```
Next, we look more in detail at the overlapping genes, with the final goal being to run MeDeCom with only lowest common denominator gene. Doing this, we can try an see if the overall pattern observe in the data can still be seen with such a low detail FS.

```{r}
# Look more in detail at gene overlap
overlap <- VennDiagram::calculate.overlap(x = list("genes_neftel2019" = genes_neftel2019, 
                                      "genes_teo2019" = genes_teo2019, 
                                      #"genes_random" = genes_random, 
                                      "genes_wang2017" = genes_wang2017
                                      #"genes_wero150" = genes_wero150
                                      )) 
print(overlap$a5)
# --> take these genes and filter beta matrix probes accordingly.
```


# KEGG enrichment analysis of gene lists

To investigate a possible functional overlap in the gene lists applied during feature selection prior to NMF, we investigate pathway enrichment using the KEGG data base in the next step.

```{r}
# load in gene lists (see chunk further up)
# combine all gene lists into one big list
all_gene_lists <- list("teo" = genes_teo2019, "neftel" = genes_neftel2019, 
                       "wang" = genes_wang2017, "gaska" = genes_wero150,
                       "var" = genes_var, "rand" = genes_random)

# map gene symbols to corresponding Entrez ID for further analysis
genes_entrez <- vector(mode = "list", length = size(all_gene_lists)[2])
for (i in 1:size(all_gene_lists)[2]){
  temp <- clusterProfiler::bitr(all_gene_lists[[i]], fromType = 'SYMBOL', 
                                toType = 'ENTREZID', OrgDb = org.Hs.eg.db)
  genes_entrez[[i]] <- temp$ENTREZID
}
names(genes_entrez) <- names(all_gene_lists)

# compare cluster with KEGG pathway database
ck <- compareCluster(geneCluster = genes_entrez, fun = enrichKEGG)#, pvalueCutoff = 0.25)
ck <- setReadable(ck, OrgDb = org.Hs.eg.db, keyType="ENTREZID")
head(ck)
```
# Visualisation of cluster results

```{r}
# plot significant pathways as dotplot
dotplot(ck)
```
```{r}
# plot pathways and related gene overlap as cluster net plot
cnetplot(ck, max.overlap = 5)
```

To better understand functional overlap outside of only the significant pathways, we make a heatmap of the adjusted p-values for the top5 pathways in each gene list, this time without pval cutoff (or a very high one at least). PAthways found only for in one gene list but not others are set to NA for the others, ans are shown in grey in the heatmap.

```{r}
# make new clusters with higher p value cutoff, as to show non-significant pathways in heatmap as well
ck1 <- compareCluster(geneCluster = genes_entrez, fun = enrichKEGG, pvalueCutoff = 1)
ck1 <- setReadable(ck1, OrgDb = org.Hs.eg.db, keyType="ENTREZID")

#Take out relevant data
cluster_data <- data.frame(ck1@compareClusterResult$Cluster, 
                           ck1@compareClusterResult$Description, 
                           ck1@compareClusterResult$qvalue)
colnames(cluster_data) <- c("genelist", "path", "qval")

# make loop to get top 5 unique pathways for each FS list
pathways <- c()
for (x in unique(cluster_data$genelist)){
  FS_id <- which(cluster_data$genelist == x)
  top_all <- cluster_data[FS_id, "path"]
  if (length(c(top_all[1:5], pathways)) == length(unique(c(top_all[1:5], pathways)))){
    pathways <- append(pathways, top_all[1:5])
  } else {
    top5 <- c()
    i <- 1
    while (length(top5) < 5){
      if (top_all[i] %in% pathways){
        i <- i+1
      } else{
        top5 <- c(top5, top_all[i])
        i <- i+1
      }
    }
    pathways <- append(pathways, top5)
  }
}

# make heatmap matrix
cluster_heat <- data.frame(matrix(NA, ncol = length(unique(cluster_data$genelist)),
                        nrow = length(pathways)))
colnames(cluster_heat) <- unique(cluster_data$genelist)
rownames(cluster_heat) <- pathways

#loop to asign qvalue for each list and pathway. If none, then NA
for (x in unique(cluster_data$genelist)){
  subset_FS <- cluster_data[which(cluster_data$genelist == x),]
  in_df <- which(subset_FS$path %in% pathways)
  in_paths <- which(pathways %in% subset_FS$path)
  cluster_heat[in_paths, x] <- subset_FS[in_df, "qval"]
}
```
```{r}
# make data -log10
cluster_heat_log <- as.matrix(-log10(cluster_heat))
#plot heatmap
superheat(cluster_heat_log, scale = F, heat.pal = c("blue", "white", "red")) 
          #order.rows = order(cluster_heat$teo))
          #heat.col.scheme = "red")#heat.na.col = "white",
```








