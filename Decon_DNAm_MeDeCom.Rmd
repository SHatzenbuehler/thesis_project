---
title: "Deconvolution Methylation data - MeDeCom"
author: "Sarah Hatzenbuehler"
date: "26 11 2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#### Non-negative Matrix Factorisation based on Lutsik et al. (2016): MeDeCom


# Packages

```{r}
library(devtools)
#devtools::install_github("lutsik/MeDeCom",ref="windows")
#devtools::install_github("rlbarter/superheat")
library(MeDeCom)
library(superheat)
library(ggplot2)
library(VennDiagram)
library(clusterProfiler)
library(org.Hs.eg.db)
```

## Loading in data

After preprocessing the raw methylation data, we extracted a matrix of beta vlaues after some filtering based on feature selection. Multiple FS criteria have been applied, and in the next steps have been used in the NMF experiments.
FS criteria: 
1) variance based
2) biologically motivated on base on published gene lists (Teo et al. 2019, Wang et al. 2017, Neftel et al. 2019, Gaska et al 2021)
3) random gene list as comparison

```{r}
#load in example data
data(example.dataset, package="MeDeCom")
```
```{r}
# load beta matrix from preprocessed data
# for preprocessed data based on biologically relevant gene lsit: _teo, _wang, _neftel, 
# _random, _wero150, _overlap
setwd("C:/Users/Sarah/Documents/Studium/Master/Systems Biology Maastricht/Thesis/R")
beta_mat <- as.matrix(read.table(file = "beta_preprocessed_overlap.txt"))
```

## Running Deconvolution
 
Before running the deconvolution, it is important to think about a number of parameters.
Ks : number range of cell types included in the mix
lambdas : range of regularisation parameter, with 0 there being no regularisation. Lambda basically restricts any possible beta values to be between 0 and 1, thus confirming closer to biology.
NINIT : number of random initialisations
NFOLDS : number of crossvalisation folds
NCORES: number of CPU cores the decon is running on
(for example numbers check the vignette: https://github.com/lutsik/MeDeCom/blob/master/vignettes/MeDeCom.md)

According to Weronicka's thesis: optimal NINIt for RNAseq = 30-50

```{r}
# Running medecom decon
medecom.result<-runMeDeCom(beta_mat, 2:10, c(0,10^(-5:-1)), NINIT=10, 
                           NFOLDS=10, ITERMAX=300, NCORES=5)

# save result
setwd("C:/Users/Sarah/Documents/Studium/Master/Systems Biology Maastricht/Thesis/R")
saveRDS(object = medecom.result, file = "Medecom_result_overlap.RDS", compress = FALSE)
```

### Result analysis

## Loading in all results
```{r}
# Reload results after saving
setwd("~/Studium/Master/Systems Biology Maastricht/Thesis/R")
medecom.result.teo <- readRDS("Medecom_result_teo.RDS")
medecom.result.var <- readRDS("Medecom_result_var.RDS")
medecom.result.wang <- readRDS("Medecom_result_wang.RDS")
medecom.result.neftel <- readRDS("Medecom_result_neftel.RDS")
medecom.result.random <- readRDS("Medecom_result_random.RDS")
medecom.result.wero <- readRDS("Medecom_result_wero150.RDS")
medecom.result.overlap <- readRDS("Medecom_result_overlap.RDS")

# also reload the beta matrices for MDS plot later
beta_mat.teo <- as.matrix(read.table(file = "beta_preprocessed_teo.txt"))
beta_mat.var <- as.matrix(read.table(file = "beta_preprocessed_var.txt"))
beta_mat.wang <- as.matrix(read.table(file = "beta_preprocessed_wang.txt"))
beta_mat.neftel <- as.matrix(read.table(file = "beta_preprocessed_neftel.txt"))
beta_mat.random <- as.matrix(read.table(file = "beta_preprocessed_random.txt"))
beta_mat.wero <- as.matrix(read.table(file = "beta_preprocessed_wero150.txt"))
beta_mat.overlap <- as.matrix(read.table(file = "beta_preprocessed_overlap.txt"))
```

## Visualisation 

# Error measures for different lambda settings

To select optimal hyperparameters, we have a look at error curves for differing lambda and number of LMCs (k). Generally, we aim to take values in the "elbow" of the curve, as this is normally a good trade-off value regarding accuracy and bias. In our case, we aim to take the highest lambda giving us the lowest CV error, at a value for k which is the lowest before a more steady drop in CV error.
Having selected both parameters, we can anaylse the results more in depth using both of them.

```{r}
# visualise CV error for different lambda
plotParameters(medecom.result.teo)#, statistic = "rmse")
plotParameters(medecom.result.var)
plotParameters(medecom.result.wang)
plotParameters(medecom.result.neftel)
plotParameters(medecom.result.random)
plotParameters(medecom.result.wero)
plotParameters(medecom.result.overlap)
```
To select optimal lambda for different k, a different visualisation can be employed:
```{r}
# line plot for set k
plotParameters(medecom.result.teo, K=4, lambdaScale="log")
plotParameters(medecom.result.var, K=4, lambdaScale="log")
plotParameters(medecom.result.wang, K=4, lambdaScale="log")
plotParameters(medecom.result.neftel, K=4, lambdaScale="log")
plotParameters(medecom.result.random, K=4, lambdaScale="log")
plotParameters(medecom.result.wero, K=4, lambdaScale="log")
plotParameters(medecom.result.overlap, K=4, lambdaScale="log")
```
# Visualise LMC distribution for different lambda

Make histogramm of LMC profiles to visualise effect of lambda regularisation. Lambda closer to zero results in a value distribution closer to 0.5, whereas higher lambdas push the methylation values more towards 0 and 1. This is closer to what we would expect in more uniform celltypes, since this suggests a more conform status of being (un)methylated per probe for each subtype.
As example we only take the NMF results with FS based on Teo et al. for this.

```{r}
# get T matrices from the results
paras.teo <- medecom.result.teo@parameters
output.teo <- medecom.result.teo@outputs
output.teo <- output.teo$'1'
T.teo <- output.teo$'T'

# get LMC profiles for k = 4 and different lambda
k4 <- data.frame(lambda_0 = T.teo[[3]], lambda_1e05 = T.teo[[12]], lambda_1e04 = T.teo[[21]],
                 lambda_0.001 = T.teo[[30]], lambda_0.01 = T.teo[[39]], lambda_0.1 = T.teo[[48]])
```

```{r}
# make histogram
par(mfrow = c(2,3))
hist(as.matrix(k4[,1:4]), main = "lambda = 0", xlab = "beta values")
hist(as.matrix(k4[,5:8]), main = "lambda = 1e-05", xlab = "beta values")
hist(as.matrix(k4[,9:12]), main = "lambda = 1e-04", xlab = "beta values")
hist(as.matrix(k4[,13:16]), main = "lambda = 0.001", xlab = "beta values")
hist(as.matrix(k4[,17:20]), main = "lambda = 0.01", xlab = "beta values")
hist(as.matrix(k4[,21:24]), main = "lambda = 0.1", xlab = "beta values")
#mtext("Beta value distribution of LMCs for different lambda", side = 3, line = -2, outer = T)
```


# Extractiong Latent Methylation components


```{r}
# extract LMCs for set lambda and K
lmcs<-getLMCs(medecom.result.teo, K=4, lambda=0.01)
str(lmcs)
```

## Visualisation of LMC relationships

# Dendrograms
Visualising the closeness of the extracted LMCs in form of dendrograms

```{r}
# dendrogram
plotLMCs(medecom.result.teo, K=4, lambda=0.01, type="dendrogram")
plotLMCs(medecom.result.var, K=4, lambda=0.01, type="dendrogram")
plotLMCs(medecom.result.wang, K=4, lambda=0.01, type="dendrogram")
plotLMCs(medecom.result.neftel, K=4, lambda=0.01, type="dendrogram")
plotLMCs(medecom.result.random, K=4, lambda=0.01, type="dendrogram")
plotLMCs(medecom.result.wero, K=4, lambda=0.01, type="dendrogram")
plotLMCs(medecom.result.overlap, K=4, lambda=0.01, type="dendrogram")
```

# MDS plots
To better view the different latent directions in the data represented by the LMCs, we plot them into MDS plots containing the original data. 

```{r}
# MDS plot with data included
plotLMCs(medecom.result.teo, K=4, lambda=0.01, type="MDS", D = beta_mat.teo)
plotLMCs(medecom.result.var, K=4, lambda=0.01, type="MDS", D = beta_mat.var)
plotLMCs(medecom.result.wang, K=4, lambda=0.01, type="MDS", D = beta_mat.wang)
plotLMCs(medecom.result.neftel, K=4, lambda=0.01, type="MDS", D = beta_mat.neftel)
plotLMCs(medecom.result.random, K=4, lambda=0.01, type="MDS", D = beta_mat.random)
plotLMCs(medecom.result.wero, K=4, lambda=0.01, type="MDS", D = beta_mat.wero)
plotLMCs(medecom.result.overlap, K=4, lambda=0.01, type="MDS", D = beta_mat.overlap)
```

```{r}
# make PCA plots to put the LMCs in 
```

## Visualise and compare LMC proportions between different FS selections

To compare NMF results for different FS prior to it, we visualise the resulting LMC proportions per subject in the form of barplots. Since in the outcome, LMCs are not consistently labelled throughout all different results, we also compare the euclidean distance among different proportion profiles to find matching ones.

```{r}
# create color palette:
library(RColorBrewer)
coul <- brewer.pal(4, "Set1") 

#create stacked bar plots of proportions
prop.teo <- getProportions(medecom.result.teo, K=4, lambda=0.01)
prop.var <- getProportions(medecom.result.var, K=4, lambda=0.01)
prop.wang <- getProportions(medecom.result.wang, K=4, lambda=0.01)
prop.neftel <- getProportions(medecom.result.neftel, K=4, lambda=0.01)
prop.random <- getProportions(medecom.result.random, K=4, lambda=0.01)
prop.wero <- getProportions(medecom.result.wero, K=4, lambda=0.01)
prop.overlap <- getProportions(medecom.result.overlap, K=4, lambda=0.01)

# Transform this data in %
data_percentage.teo <- apply(prop.teo, 2, function(x){x*100/sum(x,na.rm=T)})
data_percentage.var <- apply(prop.var, 2, function(x){x*100/sum(x,na.rm=T)})
data_percentage.wang <- apply(prop.wang, 2, function(x){x*100/sum(x,na.rm=T)})
data_percentage.neftel <- apply(prop.neftel, 2, function(x){x*100/sum(x,na.rm=T)})
data_percentage.random <- apply(prop.random, 2, function(x){x*100/sum(x,na.rm=T)})
data_percentage.wero <- apply(prop.wero, 2, function(x){x*100/sum(x,na.rm=T)})
data_percentage.overlap <- apply(prop.overlap, 2, function(x){x*100/sum(x,na.rm=T)})
 
# Make a stacked barplot
barplot(data_percentage.teo, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Teo 2019", 
        legend.text = rownames(data_percentage.teo))
barplot(data_percentage.var, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Variance")
barplot(data_percentage.wang, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Wang 2017")
barplot(data_percentage.neftel, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Neftel 2019")
barplot(data_percentage.random, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for random FS")
barplot(data_percentage.wero, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Gaska 2021")
barplot(data_percentage.overlap, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on minimal overlapping genes")
```

For better comparison, we are taking a look at the first three samples and try to establish which LMCs have similar proportions
```{r}
# Stacked barplots for first 5 samples
barplot(data_percentage.teo[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", main="cell type proportion for FS based on Teo 2019\nSamples 1-5")
barplot(data_percentage.var[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", main="cell type proportion for FS based on Variance\nSamples 1-5")
barplot(data_percentage.wang[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", main="cell type proportion for FS based on Wang 2017\nSamples 1-5")
barplot(data_percentage.neftel[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", 
        main="cell type proportion for FS based on Neftel 2019\nSamples 1-5")
barplot(data_percentage.random[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", main="cell type proportion for random FS\nSamples 1-5")
barplot(data_percentage.wero[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", main="cell type proportion for FS based on Gaska 2021\nSamples 1-5")
barplot(data_percentage.overlap[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", 
        main="cell type proportion for FS based on minimal overlap\nSamples 1-5")
```

To sort the LMCs according to most similar patterns across all FS, we correlate each LMC-row of one FS dataset with all rows of another. Best correlation is considered concordant LMC.
Another approach is to calculate the euclidean distance between rows of two data sets to find the best match.
```{r}
# Euclidean distance matrix
ref.teo <- prop.teo
rownames(ref.teo) <- c("Teo LMC1", "Teo LMC2", "Teo LMC3", "Teo LMC4")

dist.var <- as.matrix(dist(rbind(ref.teo, prop.var), method = "euclidean"))
dist.wang <- as.matrix(dist(rbind(ref.teo, prop.wang), method = "euclidean"))
dist.neftel <- as.matrix(dist(rbind(ref.teo, prop.neftel), method = "euclidean"))
dist.random <- as.matrix(dist(rbind(ref.teo, prop.random), method = "euclidean"))
dist.wero <- as.matrix(dist(rbind(ref.teo, prop.wero), method = "euclidean"))
dist.overlap <- as.matrix(dist(rbind(ref.teo, prop.overlap), method = "euclidean"))

# visualise
heatmap(dist.var, main = "Teo vs Variance - Euclidean Distance")
#heatmap(dist.var[1:4, 5:8]) # for single values
heatmap(dist.wang, main = "Teo vs Wang - Euclidean Distance")
heatmap(dist.neftel, main = "Teo vs Neftel - Euclidean Distance")
heatmap(dist.random, main = "Teo vs Random - Euclidean Distance")
heatmap(dist.wero, main = "Teo vs Gaska - Euclidean Distance")
heatmap(dist.overlap, main = "Teo vs overlap - Euclidean Distance")

# get vector of lowest distance to use for reordering
index.var <- unname(apply(dist.var[1:4, 5:8], 1, which.min))
index.wang <- unname(apply(dist.wang[1:4, 5:8], 1, which.min))
index.neftel <- unname(apply(dist.neftel[1:4, 5:8], 1, which.min))
index.random <- unname(apply(dist.random[1:4, 5:8], 1, which.min))
index.wero <- unname(apply(dist.wero[1:4, 5:8], 1, which.min))
index.overlap <- unname(apply(dist.overlap[1:4, 5:8], 1, which.min))
```

For better and clearer overview, we compile all distance measures into one heatmap

```{r}
# make all distance matrices into one
# rename proportion vectors
ref.var <- prop.var
rownames(ref.var) <- c("Var LMC1", "Var LMC2", "Var LMC3", "Var LMC4")
ref.wang <- prop.wang
rownames(ref.wang) <- c("Wang LMC1", "Wang LMC2", "Wang LMC3", "Wang LMC4")
ref.neftel <- prop.neftel
rownames(ref.neftel) <- c("Neftel LMC1", "Neftel LMC2", "Neftel LMC3", "Neftel LMC4")
ref.random <- prop.random
rownames(ref.random) <- c("Random LMC1", "Random LMC2", "Random LMC3", "Random LMC4")
ref.wero <- prop.wero
rownames(ref.wero) <- c("Gaska LMC1", "Gaska LMC2", "Gaska LMC3", "Gaska LMC4")
ref.overlap <- prop.overlap
rownames(ref.overlap) <- c("Overlap LMC1", "Overlap LMC2", "Overlap LMC3", "Overlap LMC4")

# make one distance matrix of all
dist.all <- as.matrix(dist(rbind(ref.teo, ref.var, ref.wang, ref.neftel, ref.overlap, 
                                 ref.wero, ref.random), method = "euclidean"))

# visualise
heatmap(dist.all, main = "Euclidean Distance between all LMC proportions")
heatmap.2(dist.all, main = "Euclidean Distance between all LMC proportions", 
          trace = "none", density.info = "none")
```

Using the corresponding LMCs across different FS results, we reorganise the barplots to better compare proportions between the results, trying to match up most similar LMC proportions for all.

```{r}
# Try again with resorting the LMC rows to match Teo
data_percentage.var1 <- data_percentage.var[index.var, ]
data_percentage.wang1 <- data_percentage.wang[index.wang,]
data_percentage.neftel1 <- data_percentage.neftel[index.neftel,]
data_percentage.random1 <- data_percentage.random[index.random,]
data_percentage.wero1 <- data_percentage.wero[index.wero,]
data_percentage.overlap1 <- data_percentage.overlap[index.overlap,]

# plot to see difference
barplot(data_percentage.teo[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", main="cell type proportion for FS based on Teo 2019\nSamples 1-5")
barplot(data_percentage.var1[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", main="cell type proportion for FS based on Variance
        \nSamples 1-5 (reorganised)")
barplot(data_percentage.wang1[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", main="cell type proportion for FS based on Wang 2017
        \nSamples 1-5 (reorganised) ")
barplot(data_percentage.neftel1[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", 
        main="cell type proportion for FS based on Neftel 2019\nSamples 1-5 (reorganised)")
barplot(data_percentage.random1[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", 
        main="cell type proportion for random FS\nSamples 1-5 (reorganised)")
barplot(data_percentage.wero1[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", 
        main="cell type proportion for FS based on Gaska 2021\nSamples 1-5 (reorganised)")
barplot(data_percentage.overlap1[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", 
        main="cell type proportion for FS based on minimal overlap\nSamples 1-5 (reorganised)")
```
```{r}
# Now print all data again in a reorganised fashion
# Make a stacked barplot
barplot(data_percentage.teo, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Teo 2019")#, 
        #legend.text = rownames(data_percentage.teo))
barplot(data_percentage.var1, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Variance \n(reorganised)")
barplot(data_percentage.wang1, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Wang 2017 \n (reorganised)")
barplot(data_percentage.neftel1, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Neftel 2019 \n (reorganised)")
barplot(data_percentage.random1, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for random FS \n (reorganised)")
barplot(data_percentage.wero1, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Gaska 2021\n (reorganised)")
barplot(data_percentage.overlap1, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on minimal overlapping genes \n (reorganised)")
```

## Analysing similarities in Feature Selection prior to NMF

To investigate how similar the criteria applied for feature selection have been, we check for common genes within the lists as well as functional similarities by means of KEGG enrichment clustering.

```{r}
# set directory
setwd("~/Studium/Master/Systems Biology Maastricht/Thesis/R")

# read in gene lists
genes_teo2019 <- unlist(read.csv(file = "Teo2019_genelist500.csv", header = F))
genes_wang2017 <- unlist(read.csv(file = "Wang2017_genelist_subtypes.csv", header = F))
genes_neftel2019 <- unlist(read.csv(file = "Neftel2019_genelist_subtypes.csv", header = F))
genes_wero150 <- unlist(read.csv(file = "Weronika_genelist_top50_geneID.csv", header = F))
genes_var <- unlist(read.csv(file = "var_genes_unique.csv", header = F))
genes_random <- unlist(read.csv(file = "random_gene_list.csv", header = F))
```

Here we check how many of the genes are overlapping in each gene list and display the results using Venn diagrams

```{r}
# make Venn diagram of gene overlap
VennDiagram::get.venn.partitions(list(genes_neftel2019 = genes_neftel2019, 
                                      genes_teo2019 = genes_teo2019, 
                                      genes_var = genes_var,
                                      genes_random = genes_random,
                                      genes_wang2017 = genes_wang2017,
                                      genes_wero150 = genes_wero150))
```

```{r}
# put all biological genes in one list
biol_genes <- unique(c(genes_neftel2019, genes_teo2019, genes_wang2017, genes_wero150))

# print Venn diagramm
grid.newpage()
grid::grid.draw(VennDiagram::venn.diagram(list(#"Biol. FS genes (944)" = biol_genes,
                                               "Neftel et al. (363)"= genes_neftel2019, 
                                               "Teo et al. (500)" = genes_teo2019, 
                                               #"Variance (3170)" = genes_var, 
                                               #"Random genes (200)" = genes_random,
                                               "Wang et al. (150)" = genes_wang2017,
                                               "Gaska (113)" = genes_wero150,
                                               NULL
                                               ),
                                          NULL))
```
Next, we look more in detail at the overlapping genes, with the final goal being to run MeDeCom with only lowest common denominator gene. Doing this, we can try an see if the overall pattern observe in the data can still be seen with such a low detail FS.

```{r}
# Look more in detail at gene overlap
overlap <- VennDiagram::calculate.overlap(x = list("genes_neftel2019" = genes_neftel2019, 
                                      "genes_teo2019" = genes_teo2019, 
                                      #"genes_random" = genes_random, 
                                      "genes_wang2017" = genes_wang2017
                                      #"genes_wero150" = genes_wero150
                                      )) 
print(overlap$a5)
# --> take these genes and filter beta matrix probes accordingly.
```


# KEGG enrichment analysis of gene lists

To investigate a possible functional overlap in the gene lists applied during feature selection prior to NMF, we investigate pathway enrichment using the KEGG data base in the next step.

```{r}
# load in gene lists (see chunk further up)
# combine all gene lists into one big list
all_gene_lists <- list("teo" = genes_teo2019, "neftel" = genes_neftel2019, 
                       "wang" = genes_wang2017, "gaska" = genes_wero150,
                       "var" = genes_var, "rand" = genes_random)

# map gene symbols to corresponding Entrez ID for further analysis
genes_entrez <- vector(mode = "list", length = size(all_gene_lists)[2])
for (i in 1:size(all_gene_lists)[2]){
  temp <- clusterProfiler::bitr(all_gene_lists[[i]], fromType = 'SYMBOL', 
                                toType = 'ENTREZID', OrgDb = org.Hs.eg.db)
  genes_entrez[[i]] <- temp$ENTREZID
}
names(genes_entrez) <- names(all_gene_lists)

# compare cluster with KEGG pathway database
ck <- compareCluster(geneCluster = genes_entrez, fun = enrichKEGG)#, pvalueCutoff = 0.25)
ck <- setReadable(ck, OrgDb = org.Hs.eg.db, keyType="ENTREZID")
head(ck)
```
# Visualisation of cluster results

```{r}
# plot significant pathways as dotplot
dotplot(ck)
```
```{r}
# plot pathways and related gene overlap as cluster net plot
cnetplot(ck, max.overlap = 5)
```

To better understand functional overlap outside of only the significant pathways, we make a heatmap of the adjusted p-values for the top5 pathways in each gene list, this time without pval cutoff (or a very high one at least). PAthways found only for in one gene list but not others are set to NA for the others, ans are shown in grey in the heatmap.

```{r}
# make new clusters with higher p value cutoff, as to show non-significant pathways in heatmap as well
ck1 <- compareCluster(geneCluster = genes_entrez, fun = enrichKEGG, pvalueCutoff = 1)
ck1 <- setReadable(ck1, OrgDb = org.Hs.eg.db, keyType="ENTREZID")

#Take out relevant data
cluster_data <- data.frame(ck1@compareClusterResult$Cluster, 
                           ck1@compareClusterResult$Description, 
                           ck1@compareClusterResult$qvalue)
colnames(cluster_data) <- c("genelist", "path", "qval")

# make loop to get top 5 unique pathways for each FS list
pathways <- c()
for (x in unique(cluster_data$genelist)){
  FS_id <- which(cluster_data$genelist == x)
  top_all <- cluster_data[FS_id, "path"]
  if (length(c(top_all[1:5], pathways)) == length(unique(c(top_all[1:5], pathways)))){
    pathways <- append(pathways, top_all[1:5])
  } else {
    top5 <- c()
    i <- 1
    while (length(top5) < 5){
      if (top_all[i] %in% pathways){
        i <- i+1
      } else{
        top5 <- c(top5, top_all[i])
        i <- i+1
      }
    }
    pathways <- append(pathways, top5)
  }
}

# make heatmap matrix
cluster_heat <- data.frame(matrix(NA, ncol = length(unique(cluster_data$genelist)),
                        nrow = length(pathways)))
colnames(cluster_heat) <- unique(cluster_data$genelist)
rownames(cluster_heat) <- pathways

#loop to asign qvalue for each list and pathway. If none, then NA
for (x in unique(cluster_data$genelist)){
  subset_FS <- cluster_data[which(cluster_data$genelist == x),]
  in_df <- which(subset_FS$path %in% pathways)
  in_paths <- which(pathways %in% subset_FS$path)
  cluster_heat[in_paths, x] <- subset_FS[in_df, "qval"]
}
```
```{r}
# make data -log10
cluster_heat_log <- as.matrix(-log10(cluster_heat))
#plot heatmap
superheat(cluster_heat_log, scale = T, heat.pal = c("blue", "white", "red")) 
          #order.rows = order(cluster_heat$teo))
          #heat.col.scheme = "red")#heat.na.col = "white",
```








