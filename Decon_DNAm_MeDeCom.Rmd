---
title: "Deconvolution Methylation data - MeDeCom"
author: "Sarah Hatzenbuehler"
date: "26 11 2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#### Non-negative Matrix Factorisation based on Lutsik et al. (2016): MeDeCom


# Packages

```{r}
suppressMessages(library(devtools))
#devtools::install_github("lutsik/MeDeCom",ref="windows")
#devtools::install_github("rlbarter/superheat")
suppressMessages(library(MeDeCom))
suppressMessages(library(superheat))
suppressMessages(library(ggplot2))
suppressMessages(library(VennDiagram))
suppressMessages(library(clusterProfiler))
suppressMessages(library(org.Hs.eg.db))
suppressMessages(library(wateRmelon))
suppressMessages(library(FlowSorted.DLPFC.450k))
suppressMessages(library(stringr))
```

## Loading in data

After preprocessing the raw methylation data, we extracted a matrix of beta values after some filtering based on feature selection. Multiple FS criteria have been applied, and in the next steps have been used in the NMF experiments.
FS criteria: 
1) variance based
2) biologically motivated on base on published gene lists (Teo et al. 2019, Wang et al. 2017, Neftel et al. 2019, Gaska et al. 2021)
3) random gene list as comparison

```{r}
#load in example data
data(example.dataset, package="MeDeCom")

# randomly select features to see if results still show same patterns
rand_idx <- sample(1:dim(D)[1], 1500)
beta_mat <- D[rand_idx, ]
```
```{r}
# load beta matrix from preprocessed data
# for preprocessed data based on biologically relevant gene lsit: _teo, _wang, _neftel, 
# _random, _wero150, _overlap
setwd("C:/Users/Sarah/Documents/Studium/Master/Systems Biology Maastricht/Thesis/R")
beta_mat <- as.matrix(read.table(file = "beta_preprocessed_var2.txt"))
```

Optional: additional filtering of the combined sample matrix to only include 23 random samples. This was done for comparison with the all black sample group of 23 patients.
```{r}
# take random 23 samples from beta_mat
rand_idx <- sample(1:dim(beta_mat)[2], 23)
beta_mat <- beta_mat[,rand_idx]

# save matrix for further analysis
setwd("C:/Users/Sarah/Documents/Studium/Master/Systems Biology Maastricht/Thesis/R")
write.table(beta_mat, "beta_preprocessed_teo_black-cauc_23.txt", sep="\t",row.names=T)
```


## Running Deconvolution
 
Before running the deconvolution, it is important to think about a number of parameters.
Ks : number range of cell types included in the mix
lambdas : range of regularisation parameter, with 0 there being no regularisation. Lambda basically restricts any possible beta values to be between 0 and 1, thus confirming closer to biology.
NINIT : number of random initialisations
NFOLDS : number of crossvalisation folds
NCORES: number of CPU cores the decon is running on
(for example numbers check the vignette: https://github.com/lutsik/MeDeCom/blob/master/vignettes/MeDeCom.md)

According to Weronicka's thesis: optimal NINIt for RNAseq = 30-50

```{r}
# Running medecom decon
medecom.result<-runMeDeCom(beta_mat, 2:10, c(0,10^(-5:-1)), NINIT=10, 
                           NFOLDS=10, ITERMAX=300, NCORES=5)

# save result
setwd("C:/Users/Sarah/Documents/Studium/Master/Systems Biology Maastricht/Thesis/R")
saveRDS(object = medecom.result, file = "Medecom_result_var2.RDS", compress = FALSE)
```

### Result analysis

## Loading in all results
```{r}
# Reload results after saving
setwd("~/Studium/Master/Systems Biology Maastricht/Thesis/R")
medecom.result.teo <- readRDS("Medecom_result_teo2.RDS")
medecom.result.var <- readRDS("Medecom_result_var2.RDS")
medecom.result.wang <- readRDS("Medecom_result_wang.RDS")
medecom.result.neftel <- readRDS("Medecom_result_neftel.RDS")
medecom.result.random <- readRDS("Medecom_result_random.RDS") 
medecom.result.wero <- readRDS("Medecom_result_wero150.RDS")
medecom.result.random_probes <- readRDS("Medecom_result_random_probes.RDS")

# also reload the beta matrices for MDS plot later
beta_mat.teo <- as.matrix(read.table(file = "beta_preprocessed_teo.txt"))
beta_mat.var <- as.matrix(read.table(file = "beta_preprocessed_var2.txt"))
beta_mat.wang <- as.matrix(read.table(file = "beta_preprocessed_wang.txt"))
beta_mat.neftel <- as.matrix(read.table(file = "beta_preprocessed_neftel.txt"))
beta_mat.random <- as.matrix(read.table(file = "beta_preprocessed_random.txt"))
beta_mat.wero <- as.matrix(read.table(file = "beta_preprocessed_wero150.txt"))
beta_mat.random_probes <- as.matrix(read.table(file = "beta_preprocessed_random_probes.txt"))
```

## Visualisation 

# Error measures for different lambda settings

To select optimal hyperparameters, we have a look at error curves for differing lambda and number of LMCs (k). Generally, we aim to take values in the "elbow" of the curve, as this is normally a good trade-off value regarding accuracy and bias. In our case, we aim to take the highest lambda giving us the lowest CV error, at a value for k which is the lowest before a more steady drop in CV error.
Having selected both parameters, we can anaylse the results more in depth using both of them.

```{r}
# visualise CV error for different lambda
plotParameters(medecom.result.teo, statistic = "rmse")
plotParameters(medecom.result.var, statistic = "rmse")
plotParameters(medecom.result.wang, statistic = "rmse")
plotParameters(medecom.result.neftel, statistic = "rmse")
plotParameters(medecom.result.random, statistic = "rmse")
plotParameters(medecom.result.wero, statistic = "rmse")
```
```{r}
# nice plots
par(mfrow = c(1,2))
plotParameters(medecom.result.random_probes, statistic = "rmse")
#mtext(expression(bold("Reconstruction error for var")), side = 3, line = -1, outer = T)
plotParameters(medecom.result.random_probes)
#mtext(expression(bold("CV error for var")), side = 3, line = -1, outer = T)
```


To select optimal lambda for different k, a different visualisation can be employed focusing on RSME and objective as well. However, for this we have to specify k.

```{r}
# line plot for set k
plotParameters(medecom.result.teo, K=4, lambdaScale="log")
plotParameters(medecom.result.var, K=4, lambdaScale="log")
plotParameters(medecom.result.wang, K=4, lambdaScale="log")
plotParameters(medecom.result.neftel, K=4, lambdaScale="log")
plotParameters(medecom.result.random, K=4, lambdaScale="log")
plotParameters(medecom.result.wero, K=4, lambdaScale="log")
plotParameters(medecom.result.overlap, K=4, lambdaScale="log")
```
# Visualise LMC distribution for different lambda

Make histogramm of LMC profiles to visualise effect of lambda regularisation. Lambda closer to zero results in a value distribution closer to 0.5, whereas higher lambdas push the methylation values more towards 0 and 1. This is closer to what we would expect in more uniform celltypes, since this suggests a more conform status of being (un)methylated per probe for each subtype.
As example we only take the NMF results with FS based on Teo et al. for this.

```{r}
# get T matrices from the results
paras.teo <- medecom.result.wang@parameters   #change input here
output.teo <- medecom.result.wang@outputs     #change input here
output.teo <- output.teo$'1'
T.teo <- output.teo$'T'

# get LMC profiles for k = 4 and different lambda
k4 <- data.frame(lambda_0 = T.teo[[3]], lambda_1e05 = T.teo[[12]], lambda_1e04 = T.teo[[21]],
                 lambda_0.001 = T.teo[[30]], lambda_0.01 = T.teo[[39]], lambda_0.1 = T.teo[[48]])
```

```{r}
# make histogram
par(mfrow = c(1,3), mar = c(4,4,8,1))
hist(as.matrix(k4[,1:4]), main = "lambda = 0", xlab = "beta values")
#hist(as.matrix(k4[,5:8]), main = "lambda = 1e-05", xlab = "beta values")
#hist(as.matrix(k4[,9:12]), main = "lambda = 1e-04", xlab = "beta values")
#hist(as.matrix(k4[,13:16]), main = "lambda = 0.001", xlab = "beta values")
hist(as.matrix(k4[,17:20]), main = "lambda = 0.01", xlab = "beta values")
hist(as.matrix(k4[,21:24]), main = "lambda = 0.1", xlab = "beta values")
mtext(expression(bold("Beta value distribution of LMCs for different lambda")), 
      side = 3, line = -2, outer = T)
```

```{r}
# to make them all the comparable LMCS, we first run the barplot part below toe get different indices
old_order <- c(17,18,19,20)
new_order <- old_order[index.wang] #change input here

# print for each individual LMC
par(mfrow = c(2,4))#, mar = c(3,3,3,3))
hist(as.matrix(k4[,new_order[1]]), main = "lambda = 0.01 for LMC1", xlab = "beta values", 
     col = "light blue")
hist(as.matrix(k4[,new_order[2]]), main = "lambda = 0.01 for LMC2", xlab = "beta values", 
     col = "light blue")
hist(as.matrix(k4[,new_order[3]]), main = "lambda = 0.01 for LMC3", xlab = "beta values", 
     col = "light blue")
hist(as.matrix(k4[,new_order[4]]), main = "lambda = 0.01 for LMC4", xlab = "beta values", 
     col = "light blue")
#mtext(expression(bold("Beta value distribution of LMC profiles for var")), 
#      side = 3, line = -2, outer = T)
```
```{r}
# Compare with the distribution of the original data
par(mfrow = c(1,2))
hist(beta_mat.random_probes, main = "beta values before NNMF (n = 94)\n filtered for random probes ", xlab = "beta values", cex.main = 1, col = "dark green") #change input here
hist(as.matrix(k4[,17:20]), main = "beta value distribution of LMCs (k = 4)\n for lambda = 0.01", 
     xlab = "beta values", cex.main = 1, col = "light green")
```

## Visualisation of LMC relationships

# Dendrograms
Visualising the closeness of the extracted LMCs in form of dendrograms

```{r}
# dendrogram
plotLMCs(medecom.result.teo, K=4, lambda=0.01, type="dendrogram")
plotLMCs(medecom.result.var, K=4, lambda=0.01, type="dendrogram")
plotLMCs(medecom.result.wang, K=4, lambda=0.01, type="dendrogram")
plotLMCs(medecom.result.neftel, K=4, lambda=0.01, type="dendrogram")
plotLMCs(medecom.result.random, K=4, lambda=0.01, type="dendrogram")
plotLMCs(medecom.result.wero, K=4, lambda=0.01, type="dendrogram")
plotLMCs(medecom.result.overlap, K=4, lambda=0.01, type="dendrogram")
```

# MDS plots
To better view the different latent directions in the data represented by the LMCs, we plot them into MDS plots containing the original data. 

```{r}
# MDS plot with data included
plotLMCs(medecom.result.teo, K=4, lambda=0.01, type="MDS", D = beta_mat.teo)
plotLMCs(medecom.result.var, K=4, lambda=0.01, type="MDS", D = beta_mat.var)
plotLMCs(medecom.result.wang, K=4, lambda=0.01, type="MDS", D = beta_mat.wang)
plotLMCs(medecom.result.neftel, K=4, lambda=0.01, type="MDS", D = beta_mat.neftel)
plotLMCs(medecom.result.random, K=4, lambda=0.01, type="MDS", D = beta_mat.random)
plotLMCs(medecom.result.wero, K=4, lambda=0.01, type="MDS", D = beta_mat.wero)
plotLMCs(medecom.result.overlap, K=4, lambda=0.01, type="MDS", D = beta_mat.overlap)
```

# PCA plots
To better interpret the distribution of the data and the different directions of the LMCs, we project them into a PCA space of the first two PCs. For this, we multiply each LMC (which is kind of a profile including weights for all probes) with the weights, or loadings, of the PCA for the data they're based off. The results of this weighted sum or dot product gives us the coordinates of the LMC in the PCA space of the data (if done for both PC1 and 2 here)

```{r}
# get T matrices from the results
paras.teo <- medecom.result.wang@parameters  #change input here
output.teo <- medecom.result.wang@outputs    #change input here
output.teo <- output.teo$'1'
Tall.teo <- output.teo$'T'
T.teo <- as.data.frame(Tall.teo[[39]])
colnames(T.teo) <- c("LMC1", "LMC2", "LMC3", "LMC4")

# make PCA plots to put the LMCs in 
pca.teo <- prcomp(t(beta_mat.wang))         #change input here
pred.lmc <- data.frame(matrix(ncol=4,nrow=4, 
                              dimnames=list(c("LMC1", "LMC2", "LMC3", "LMC4"),
                                            c("PC1", "PC2", "PC3", "PC4"))))
#adjust LMCs to be same for exery experiment
T.teo <- T.teo[,index.wang]                #change input here

# project LMCs into PCA space
for (i in 1:dim(T.teo)[2]){
  pred.lmc[i,1] <- (T.teo[,i] - pca.teo$center) %*% pca.teo$rotation[,1]
  pred.lmc[i,2] <- (T.teo[,i] - pca.teo$center) %*% pca.teo$rotation[,2]
}
```
```{r}
plot(pca.teo$x[,1:2], xlim = c(min(pred.lmc[,1])-1, max(pred.lmc[,1]+1)), 
     ylim = c(min(pred.lmc[,2])-1, max(pred.lmc[,2]+2)), pch = 16, 
     main = "PCA of LMC projection filtered for teo")
points(pred.lmc[index.teo,1:2], col = "red", pch = 16)
text(pred.lmc, labels = rownames(pred.lmc), pos = 3)
#text(pred.lmc[,1:2], labels = rownames(pred.lmc[index.random,]), pos = 3) # taken from after heatmaps
```

```{r}
# have a look at PC 3 and 4 to see the 4th LMC better
# create Coordniates for PC3 and 4 for LMCs
for (i in 1:dim(T.teo)[2]){
  pred.lmc[i,3] <- (T.teo[,i] - pca.teo$center) %*% pca.teo$rotation[,3]
  pred.lmc[i,4] <- (T.teo[,i] - pca.teo$center) %*% pca.teo$rotation[,4]
  #pred.lmc[i,5] <- (T.teo[,i] - pca.teo$center) %*% pca.teo$rotation[,5]
}
```
```{r}
# plot multiple PCA spaces
idx <- subset(expand.grid(x=1:4,y=1:4),x!=y)
i <-1
pairs(pca.teo$x[,1:4], pch=16, xlim = c(min(pred.lmc-1), max(pred.lmc+1)), 
      ylim = c(min(pred.lmc-1), max(pred.lmc+1)), 
            panel=function(x, y, ...) {
                points(x, y, pch=16, cex = 1.5)
                points(pred.lmc[,idx[i,"y"]],pred.lmc[,idx[i,"x"]],
                             cex=1.7,pch=16,col='red')
                text(pred.lmc[,idx[i,"y"]],pred.lmc[,idx[i,"x"]], 
                     #labels = rownames(pred.lmc[index.var,]), pos = 3)
                     labels = rownames(pred.lmc), pos = 3)
                i <<- i +1},
      main = "PCA of LMC projection filtered for random probes"
            )
```

### Try and  add previously esatblished groups for patients as colours into PCA

```{r}
# read in clinical data
setwd("~/Studium/Master/Systems Biology Maastricht/Thesis/R")
clinical <- readRDS(file = "clinical.RDS")
#rename sample IDS to match beta matrices
new_IDs <- str_replace_all(rownames(clinical), '-', '.')
rownames(clinical) <- new_IDs
# find corresponding patients
sample_IDs <- which(rownames(clinical) %in% colnames(beta_mat.teo))
# extract relevant group info
group_type <- clinical$paper_Original.Subtype[sample_IDs]
group_type_meth <- clinical$paper_Pan.Glioma.DNA.Methylation.Cluster[sample_IDs]

# Make PCA
# get T matrices from the results
paras.teo <- medecom.result.neftel@parameters  #change input here
output.teo <- medecom.result.neftel@outputs    #change input here
output.teo <- output.teo$'1'
Tall.teo <- output.teo$'T'
T.teo <- as.data.frame(Tall.teo[[39]])
colnames(T.teo) <- c("LMC1", "LMC2", "LMC3", "LMC4")

# make PCA plots to put the LMCs in 
pca.teo <- prcomp(t(beta_mat.neftel))         #change input here
pred.lmc <- data.frame(matrix(ncol=4,nrow=4, 
                              dimnames=list(c("LMC1", "LMC2", "LMC3", "LMC4"),
                                            c("PC1", "PC2", "PC3", "PC4"))))
for (i in 1:dim(T.teo)[2]){
  pred.lmc[i,1] <- (T.teo[,i] - pca.teo$center) %*% pca.teo$rotation[,1]
  pred.lmc[i,2] <- (T.teo[,i] - pca.teo$center) %*% pca.teo$rotation[,2]
}
```
```{r}
plot(pca.teo$x[,1:2], xlim =c(-10, 10), ylim = c(-10,10), pch = 16, col = group_type_meth,
     main = "PCA of LMC projection filtered for Neftel et al.")
points(pred.lmc[,1:2], col = "red", pch = 16)
text(pred.lmc, labels = rownames(pred.lmc), pos = 3)
#text(pred.lmc[,1:2], labels = rownames(pred.lmc[index.random,]), pos = 3) # taken from after heatmaps
# add legend
```
```{r}
# have a look at PC 3 and 4 to see the 4th LMC better
# create Coordniates for PC3 and 4 for LMCs
for (i in 1:dim(T.teo)[2]){
  pred.lmc[i,3] <- (T.teo[,i] - pca.teo$center) %*% pca.teo$rotation[,3]
  pred.lmc[i,4] <- (T.teo[,i] - pca.teo$center) %*% pca.teo$rotation[,4]
  #pred.lmc[i,5] <- (T.teo[,i] - pca.teo$center) %*% pca.teo$rotation[,5]
}
```
```{r}
# plot multiple PCA spaces
idx <- subset(expand.grid(x=1:4,y=1:4),x!=y)
i <-1
pairs(pca.teo$x[,1:4], pch=16, xlim = c(min(pred.lmc-1), max(pred.lmc+1)), 
      ylim = c(min(pred.lmc-1), max(pred.lmc+1)), 
            panel=function(x, y, ...) {
                points(x, y, pch=16, cex = 1.5, col = group_type_meth)
                points(pred.lmc[,idx[i,"y"]],pred.lmc[,idx[i,"x"]],
                             cex=1.7,pch=16,col='red')
                text(pred.lmc[,idx[i,"y"]],pred.lmc[,idx[i,"x"]], 
                     #labels = rownames(pred.lmc[index.random,]), pos = 3)
                     labels = rownames(pred.lmc), pos = 3)
                i <<- i +1},
      main = "PCA of LMC projection filtered for Neftel et al."
            )
```



## Visualise and compare LMC proportions between different FS selections

To compare NMF results for different FS prior to it, we visualise the resulting LMC proportions per subject in the form of barplots. Since in the outcome, LMCs are not consistently labelled throughout all different results, we also compare the euclidean distance among different proportion profiles to find matching ones.

```{r}
# create color palette:
library(RColorBrewer)
coul <- brewer.pal(4, "PRGn") 

#create stacked bar plots of proportions
prop.teo <- getProportions(medecom.result.teo, K=4, lambda=0.01)
prop.var <- getProportions(medecom.result.var, K=4, lambda=0.01)
prop.wang <- getProportions(medecom.result.wang, K=4, lambda=0.01)
prop.neftel <- getProportions(medecom.result.neftel, K=4, lambda=0.01)
prop.random <- getProportions(medecom.result.random, K=4, lambda=0.01)
prop.wero <- getProportions(medecom.result.wero, K=4, lambda=0.01)
prop.random_probes <- getProportions(medecom.result.random_probes, K=4, lambda=0.01)

# Transform this data in %
data_percentage.teo <- apply(prop.teo, 2, function(x){x*100/sum(x,na.rm=T)})
data_percentage.var <- apply(prop.var, 2, function(x){x*100/sum(x,na.rm=T)})
data_percentage.wang <- apply(prop.wang, 2, function(x){x*100/sum(x,na.rm=T)})
data_percentage.neftel <- apply(prop.neftel, 2, function(x){x*100/sum(x,na.rm=T)})
data_percentage.random <- apply(prop.random, 2, function(x){x*100/sum(x,na.rm=T)})
data_percentage.wero <- apply(prop.wero, 2, function(x){x*100/sum(x,na.rm=T)})
data_percentage.random_probes <- apply(prop.random_probes, 2, function(x){x*100/sum(x,na.rm=T)})
 
# Make a stacked barplot
barplot(data_percentage.teo, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Teo 2019", 
        legend.text = rownames(data_percentage.teo))
barplot(data_percentage.var, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Variance")
barplot(data_percentage.wang, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Wang 2017")
barplot(data_percentage.neftel, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Neftel 2019")
barplot(data_percentage.random, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for random FS")
barplot(data_percentage.wero, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Gaska 2021")
```

For better comparison, we are taking a look at the first three samples and try to establish which LMCs have similar proportions
```{r}
# Stacked barplots for first 5 samples
barplot(data_percentage.teo[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", main="cell type proportion for FS based on Teo 2019\nSamples 1-5")
barplot(data_percentage.var[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", main="cell type proportion for FS based on Variance\nSamples 1-5")
barplot(data_percentage.wang[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", main="cell type proportion for FS based on Wang 2017\nSamples 1-5")
barplot(data_percentage.neftel[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", 
        main="cell type proportion for FS based on Neftel 2019\nSamples 1-5")
barplot(data_percentage.random[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", main="cell type proportion for random FS\nSamples 1-5")
barplot(data_percentage.wero[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", main="cell type proportion for FS based on Gaska 2021\nSamples 1-5")
```

To sort the LMCs according to most similar patterns across all FS, we correlate each LMC-row of one FS dataset with all rows of another. Best correlation is considered concordant LMC.
Another approach is to calculate the euclidean distance between rows of two data sets to find the best match.
```{r}
# Euclidean distance matrix
ref.var <- prop.var
rownames(ref.var) <- c("var LMC1", "var LMC2", "var LMC3", "var LMC4")

dist.teo <- as.matrix(dist(rbind(ref.var, prop.teo), method = "euclidean"))
dist.wang <- as.matrix(dist(rbind(ref.var, prop.wang), method = "euclidean"))
dist.neftel <- as.matrix(dist(rbind(ref.var, prop.neftel), method = "euclidean"))
dist.random <- as.matrix(dist(rbind(ref.var, prop.random), method = "euclidean"))
dist.wero <- as.matrix(dist(rbind(ref.var, prop.wero), method = "euclidean"))
dist.random_probes <- as.matrix(dist(rbind(ref.var, prop.random_probes), method = "euclidean"))

# visualise
heatmap(dist.teo, main = "var vs teo - Euclidean Distance")
#heatmap(dist.var[1:4, 5:8]) # for single values
heatmap(dist.wang, main = "var vs Wang - Euclidean Distance")
heatmap(dist.neftel, main = "var vs Neftel - Euclidean Distance")
heatmap(dist.random, main = "var vs Random - Euclidean Distance")
heatmap(dist.wero, main = "var vs Gaska - Euclidean Distance")
heatmap(dist.random_probes, main = "var vs random_probes - Euclidean Distance")

# get vector of lowest distance to use for reordering
index.teo <- unname(apply(dist.teo[1:4, 5:8], 1, which.min))
index.wang <- unname(apply(dist.wang[1:4, 5:8], 1, which.min))
index.neftel <- unname(apply(dist.neftel[1:4, 5:8], 1, which.min))
index.random <- unname(apply(dist.random[1:4, 5:8], 1, which.min))
index.wero <- unname(apply(dist.wero[1:4, 5:8], 1, which.min))
index.random_probes <- unname(apply(dist.random_probes[1:4, 5:8], 1, which.min))
```

For better and clearer overview, we compile all distance measures into one heatmap

```{r}
# make all distance matrices into one
# rename proportion vectors
ref.teo <- prop.teo[index.teo,]
rownames(ref.teo) <- c("teo LMC1", "teo LMC2", "teo LMC3", "teo LMC4")
ref.wang <- prop.wang[index.wang,]
rownames(ref.wang) <- c("wang LMC1", "wang LMC2", "wang LMC3", "wang LMC4")
ref.neftel <- prop.neftel[index.neftel,]
rownames(ref.neftel) <- c("neftel LMC1", "Neftel LMC2", "Neftel LMC3", "Neftel LMC4")
ref.random <- prop.random[index.random,]
rownames(ref.random) <- c("random_G LMC1", "random_G LMC2", "random_G LMC3", "random_G LMC4")
ref.wero <- prop.wero[index.wero,]
rownames(ref.wero) <- c("gaska LMC1", "gaska LMC2", "gaska LMC3", "gaska LMC4")
ref.random_probes <- prop.random_probes[index.random_probes,]
rownames(ref.random_probes) <- c("random_P LMC1", "random_P LMC2", "random_P LMC3",
                                 "random_P LMC4")

# make one distance matrix of all
dist.all <- as.matrix(dist(rbind(ref.teo, ref.var, ref.wang, ref.neftel, ref.random_probes, 
                                 ref.wero, ref.random), method = "euclidean"))
```
```{r}
# visualise
#heatmap(dist.all, main = "Euclidean Distance between all LMC proportions")
heatmap.2(dist.all, main = "Similarity of LMC proportions", 
          trace = "none", density.info = "none", margins =c(8,8))
```

Using the corresponding LMCs across different FS results, we reorganise the barplots to better compare proportions between the results, trying to match up most similar LMC proportions for all.

```{r}
# Try again with resorting the LMC rows to match Teo
data_percentage.teo1 <- data_percentage.teo[index.teo, ]
data_percentage.wang1 <- data_percentage.wang[index.wang,]
data_percentage.neftel1 <- data_percentage.neftel[index.neftel,]
data_percentage.random1 <- data_percentage.random[index.random,]
data_percentage.wero1 <- data_percentage.wero[index.wero,]
data_percentage.random_probes1 <- data_percentage.random_probes[index.random_probes,]

# plot to see difference
barplot(data_percentage.teo1[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", main="cell type proportion for FS based on Teo 2019\nSamples 1-5")
barplot(data_percentage.var[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", main="cell type proportion for FS based on Variance
        \nSamples 1-5 (reorganised)")
barplot(data_percentage.wang1[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", main="cell type proportion for FS based on Wang 2017
        \nSamples 1-5 (reorganised) ")
barplot(data_percentage.neftel1[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", 
        main="cell type proportion for FS based on Neftel 2019\nSamples 1-5 (reorganised)")
barplot(data_percentage.random1[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", 
        main="cell type proportion for random FS\nSamples 1-5 (reorganised)")
barplot(data_percentage.wero1[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", 
        main="cell type proportion for FS based on Gaska 2021\nSamples 1-5 (reorganised)")
barplot(data_percentage.random_probes1[, 1:5], col=coul , border="white", xlab="samples", 
        ylab = "cell type %", 
        main="cell type proportion for FS based on random_probes\nSamples 1-5 (reorganised)")
```
```{r}
# Now print all data again in a reorganised fashion
# Make a stacked barplot
par(mar=c(5,5,5,8))
barplot(data_percentage.teo1, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Teo 2019", 
        legend.text = rownames(data_percentage.teo),
        args.legend = list(x = "right", bty = "y", inset=c(-0.15, 0)))
barplot(data_percentage.var, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Variance \n(reorganised)")
barplot(data_percentage.wang1, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Wang 2017 \n (reorganised)")
barplot(data_percentage.neftel1, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Neftel 2019 \n (reorganised)")
barplot(data_percentage.random1, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for random FS \n (reorganised)")
barplot(data_percentage.wero1, col=coul , border="white", xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on Gaska 2021\n (reorganised)")
barplot(data_percentage.random_probes1, col=coul , border="white", 
        xlab="samples", ylab = "cell type %",
        main="cell type proportion for FS based on random_probes \n (reorganised)")
```

## Cross-checking with non-caucasian samples

```{r}
# load data in
setwd("~/Studium/Master/Systems Biology Maastricht/Thesis/R")
medecom.result.black_teo <- readRDS("Medecom_result_teo_black.RDS")
medecom.result.black_var <- readRDS("Medecom_result_var_black.RDS")

beta_mat.black_teo <- as.matrix(read.table(file = "beta_preprocessed_teo_black.txt"))
beta_mat.black_var <- as.matrix(read.table(file = "beta_preprocessed_var_black.txt"))
```

```{r}
# plot CV error curves for optimal k and lambda
plotParameters(medecom.result.black_teo)
plotParameters(medecom.result.black_var)
```
```{r}
# create proportion plots
prop.black_teo <- getProportions(medecom.result.black_teo, K=4, lambda=0.01)
prop.black_var <- getProportions(medecom.result.black_var, K=4, lambda=0.01)

data_percentage.black_teo <- apply(prop.black_teo, 2, function(x){x*100/sum(x,na.rm=T)})
data_percentage.black_var <- apply(prop.black_var, 2, function(x){x*100/sum(x,na.rm=T)})

# relate proportions to one another
ref.black_teo <- prop.black_teo
rownames(ref.black_teo) <- c("Black Teo LMC1", "Black Teo LMC2", "Black Teo LMC3", 
                             "Black Teo LMC4")
ref.black_var <- prop.black_var
rownames(ref.black_var) <- c("Black var LMC1", "Black var LMC2", "Black var LMC3", 
                             "Black var LMC4")
# Heatmap of distance between both black runs
dist.black <- as.matrix(dist(rbind(ref.black_teo, ref.black_var), method = "euclidean"))
par(cex.main=.8)
heatmap(dist.black, main = "Black: Teo vs Variance - Euclidean Distance", margins = c(9,9))
```
```{r}
# cross check distance with previous experiments
# match probes for Teo black and Teo caucasian
probe_idx_cau <- which(rownames(beta_mat.teo) %in% rownames(beta_mat.black_teo))
probe_idx_bl <- which(rownames(beta_mat.black_teo) %in% rownames(beta_mat.teo))

# extract LMC profiles for both and select only matching probes
paras.teo <- medecom.result.teo@parameters  
output.teo <- medecom.result.teo@outputs    
output.teo <- output.teo$'1'
Tall.teo <- output.teo$'T'
T.teo <- as.data.frame(Tall.teo[[39]])
colnames(T.teo) <- c("LMC1 Cauc", "LMC2 Cauc", "LMC3 Cauc", "LMC4 Cauc")
T.teo_m <- T.teo[probe_idx_cau,]
rownames(T.teo_m) <- rownames(beta_mat.teo[probe_idx_cau,])

paras.black_teo <- medecom.result.black_teo@parameters  # change input here 
output.black_teo <- medecom.result.black_teo@outputs    # change input here
output.black_teo <- output.black_teo$'1'
Tall.black_teo <- output.black_teo$'T'
T.black_teo <- as.data.frame(Tall.black_teo[[39]])
colnames(T.black_teo) <- c("LMC1 Black", "LMC2 Black", "LMC3 Black", "LMC4 Black")
T.black_teo_m <- T.black_teo[probe_idx_bl,]
rownames(T.black_teo_m) <- rownames(beta_mat.black_teo[probe_idx_bl,]) # and here

# correlate both LMC profile
dist.cau_bl <- as.matrix(dist(rbind(t(T.black_teo_m), t(T.teo_m)), method = "euclidean"))
par(cex.main=.8)
heatmap(dist.cau_bl, main = "Caucasion vs Black for Teo filtered", 
         margins = c(8,8))
```


## Analysing similarities in Feature Selection prior to NNMF

To investigate how similar the criteria applied for feature selection have been, we check for common genes within the lists as well as functional similarities by means of KEGG enrichment clustering.

```{r}
# set directory
setwd("~/Studium/Master/Systems Biology Maastricht/Thesis/R")

# read in gene lists
genes_teo2019 <- unlist(read.csv(file = "Teo2019_genelist500.csv", header = F))
genes_wang2017 <- unlist(read.csv(file = "Wang2017_genelist_subtypes.csv", header = F))
genes_neftel2019 <- unlist(read.csv(file = "Neftel2019_genelist_subtypes.csv", header = F))
genes_wero150 <- unlist(read.csv(file = "Weronika_genelist_top50_geneID.csv", header = F))
genes_var <- unlist(read.csv(file = "var_genes_unique.csv", header = F))
genes_random <- unlist(read.csv(file = "random_gene_list.csv", header = F))
```

Here we check how many of the genes are overlapping in each gene list and display the results using Venn diagrams

```{r}
# make Venn diagram of gene overlap
VennDiagram::get.venn.partitions(list(genes_neftel2019 = genes_neftel2019, 
                                      genes_teo2019 = genes_teo2019, 
                                      genes_var = genes_var,
                                      genes_random = genes_random,
                                      genes_wang2017 = genes_wang2017,
                                      genes_wero150 = genes_wero150))
```

```{r}
# put all biological genes in one list
biol_genes <- unique(c(genes_neftel2019, genes_teo2019, genes_wang2017, genes_wero150))

# print Venn diagramm
grid.newpage()
grid::grid.draw(VennDiagram::venn.diagram(list(#"Biol. FS genes (944)" = biol_genes,
                                               "Neftel et al. (363)"= genes_neftel2019, 
                                               "Teo et al. (500)" = genes_teo2019, 
                                               #"Variance (3170)" = genes_var, 
                                               #"Random genes (200)" = genes_random,
                                               "Wang et al. (150)" = genes_wang2017,
                                               "Gaska (113)" = genes_wero150,
                                               NULL
                                               ),
                                          NULL))
```
Next, we look more in detail at the overlapping genes, with the final goal being to run MeDeCom with only lowest common denominator gene. Doing this, we can try an see if the overall pattern observe in the data can still be seen with such a low detail FS.

```{r}
# Look more in detail at gene overlap
overlap <- VennDiagram::calculate.overlap(x = list("genes_neftel2019" = genes_neftel2019, 
                                      "genes_teo2019" = genes_teo2019, 
                                      #"genes_random" = genes_random, 
                                      "genes_wang2017" = genes_wang2017
                                      #"genes_wero150" = genes_wero150
                                      )) 
print(overlap$a5)
# --> take these genes and filter beta matrix probes accordingly.
```


# KEGG enrichment analysis of gene lists

To investigate a possible functional overlap in the gene lists applied during feature selection prior to NMF, we investigate pathway enrichment using the KEGG data base in the next step.

```{r}
# load in gene lists (see chunk further up)
# combine all gene lists into one big list
all_gene_lists <- list("teo" = genes_teo2019, "neftel" = genes_neftel2019, 
                       "wang" = genes_wang2017, "gaska" = genes_wero150,
                       "var" = genes_var, "rand" = genes_random)

# map gene symbols to corresponding Entrez ID for further analysis
genes_entrez <- vector(mode = "list", length = size(all_gene_lists)[2])
for (i in 1:size(all_gene_lists)[2]){
  temp <- clusterProfiler::bitr(all_gene_lists[[i]], fromType = 'SYMBOL', 
                                toType = 'ENTREZID', OrgDb = org.Hs.eg.db)
  genes_entrez[[i]] <- temp$ENTREZID
}
names(genes_entrez) <- names(all_gene_lists)

# compare cluster with KEGG pathway database
ck <- compareCluster(geneCluster = genes_entrez, fun = enrichKEGG)#, pvalueCutoff = 0.25)
ck <- setReadable(ck, OrgDb = org.Hs.eg.db, keyType="ENTREZID")
head(ck)
```
# Visualisation of cluster results

```{r}
# plot significant pathways as dotplot
dotplot(ck)
```
```{r}
# plot pathways and related gene overlap as cluster net plot
cnetplot(ck, max.overlap = 5)
```

To better understand functional overlap outside of only the significant pathways, we make a heatmap of the adjusted p-values for the top5 pathways in each gene list, this time without pval cutoff (or a very high one at least). PAthways found only for in one gene list but not others are set to NA for the others, ans are shown in grey in the heatmap.

```{r}
# make new clusters with higher p value cutoff, as to show non-significant pathways in heatmap as well
ck1 <- compareCluster(geneCluster = genes_entrez, fun = enrichKEGG, pvalueCutoff = 1)
ck1 <- setReadable(ck1, OrgDb = org.Hs.eg.db, keyType="ENTREZID")

#Take out relevant data
cluster_data <- data.frame(ck1@compareClusterResult$Cluster, 
                           ck1@compareClusterResult$Description, 
                           ck1@compareClusterResult$qvalue)
colnames(cluster_data) <- c("genelist", "path", "qval")

# make loop to get top 5 unique pathways for each FS list
pathways <- c()
for (x in unique(cluster_data$genelist)){
  FS_id <- which(cluster_data$genelist == x)
  top_all <- cluster_data[FS_id, "path"]
  if (length(c(top_all[1:5], pathways)) == length(unique(c(top_all[1:5], pathways)))){
    pathways <- append(pathways, top_all[1:5])
  } else {
    top5 <- c()
    i <- 1
    while (length(top5) < 5){
      if (top_all[i] %in% pathways){
        i <- i+1
      } else{
        top5 <- c(top5, top_all[i])
        i <- i+1
      }
    }
    pathways <- append(pathways, top5)
  }
}

# make heatmap matrix
cluster_heat <- data.frame(matrix(NA, ncol = length(unique(cluster_data$genelist)),
                        nrow = length(pathways)))
colnames(cluster_heat) <- unique(cluster_data$genelist)
rownames(cluster_heat) <- pathways

#loop to asign qvalue for each list and pathway. If none, then NA
for (x in unique(cluster_data$genelist)){
  subset_FS <- cluster_data[which(cluster_data$genelist == x),]
  in_df <- which(subset_FS$path %in% pathways)
  in_paths <- which(pathways %in% subset_FS$path)
  cluster_heat[in_paths, x] <- subset_FS[in_df, "qval"]
}
```
```{r}
# make data -log10
cluster_heat_log <- as.matrix(-log10(cluster_heat))
#plot heatmap
superheat(cluster_heat_log, scale = F, heat.pal = c("blue", "white", "red")) 
          #order.rows = order(cluster_heat$teo))
          #heat.col.scheme = "red")#heat.na.col = "white",
```


# Estimate Cell counts using Watermelon method

```{r}
# load renomred methylumi object from files
setwd("C:/Users/Sarah/Documents/Studium/Master/Systems Biology Maastricht/Thesis/R")
mset_renorm <- readRDS(file = "MSet_renorm.RDS")

medecom.result.neftel <- readRDS("Medecom_result_neftel.RDS")
beta_mat.neftel <- as.matrix(read.table(file = "beta_preprocessed_neftel.txt"))
```
```{r}
# run Housseman's cellcount estimate algorithm
ecc <- estimateCellCounts.wmln(mset_renorm, referencePlatform = "IlluminaHumanMethylation450k",
                               compositeCellType = "DLPFC", cellTypes = c("NeuN_neg", "NeuN_pos"),
                               returnAll = T)
```
Here, I am trying to match up my LMC proportions to the Neuron-negative cell proportions of the Houseman function from above. To do this, I am running a matrix multiplication of all 4 LMC proportions with a binary matrix of all possible recombinations. 
To compare this between different feature selections, I'd need to first match up the LMCs (see above), so for now I am doing just Teo. 
However, the Neuron-positive proportion part is, depending on the sample, extremely small. So it is hard to find a definitve answer. I will try to do a similar analysis with a combination of percentages and profiles.

```{r}
# find most likely combination of LMC profile percentages adding up to ecc percentages
prop_lmc <- getProportions(medecom.result.neftel, K=4, lambda=0.01)
prop_Nneg <- ecc$counts[,1]

# create binary matrix with all possible combinations of LMC percentages
m_comb <- as.data.frame(expand.grid(lapply(1:4, function(x) c(0, 1))))

# make loop to find best recombination per sample
m_prop <- as.data.frame(matrix(, nrow = dim(m_comb[2]), ncol = length(prop_Nneg)))
m_err <- as.data.frame(matrix(, nrow = dim(m_comb[2]), ncol = length(prop_Nneg)))
err_min <- vector(mode="numeric", length=length(prop_Nneg))

for (i in 1:length(prop_Nneg)){
  m_prop[,i] <- as.matrix(m_comb) %*% as.matrix(prop_lmc[,i])
  m_err[,i] <- prop_Nneg[i] - m_prop[,i]
  err_min[i] <- which(abs(m_err[,i]) == min(abs(m_err[,i])))
}

hist(err_min)
```


```{r}
# trying the above with a recombination of percentages and profiles
# matching profile probes
probe_idx <- which(rownames(ecc$compTable) %in% rownames(beta_mat.neftel))
prf_ecc <- ecc$compTable[probe_idx, "NeuN_neg"]

# extracting LMC profiles
output <- medecom.result.neftel@outputs    
output <- output$'1'
all_prfs_lmc <- output$'T'
prf_lmc <- all_prfs_lmc[[39]]

# Redo the combination analysis
# create binary matrix with all possible combinations of LMC percentages
m_comb <- as.matrix(expand.grid(lapply(1:4, function(x) c(0, 1))))

# make loop to find best recombination per sample
### doesnt make sense this way --- need to figure out
m_prf_all<- vector(mode="list", length=dim(prop_lmc)[2])
m_prf <- as.data.frame(matrix(, ncol = dim(m_comb)[1], nrow = dim(prf_lmc)[1]))
m_err_prf <- as.data.frame(matrix(, ncol = dim(m_comb)[1], nrow = dim(prop_lmc)[2]))
err_min_prf <- vector(mode="numeric", length=dim(prop_lmc)[2])

for (i in 1:dim(prop_lmc)[2]){
  # multiply LMC profiles for all 4 LMC with the proportion per subject
  # then matrix multiply all combination of the 4 profiles
  m_prf <- (prf_lmc * outer(rep.int(1L, nrow(prf_lmc)), prop_lmc[,i])) %*% t(m_comb)
  m_prf_all[i] <- list(m_prf)
  
  # next, calculate the distance of each of these recombinations with the ECC profile * proportion
  ecc_prf_prop <- prf_ecc * prop_Nneg[i]
  #m_err_prf[i,] <- dist(rbind(m_prf, ecc_prf_prop))
  f2 <- function(x, y) dist(rbind(x,y))
  m_err_prf[i,] <- sapply(as.list(as.data.frame(m_prf)), FUN = f2, y = ecc_prf_prop)
  
  
  # find minimal distance across all combinations
  err_min_prf[i] <- which(abs(m_err_prf[i,]) == min(abs(m_err_prf[i,])))
}

hist(err_min_prf)
heatmap.2(as.matrix(m_err_prf))
```

```{r}
# one last comparison of just the profile recombination
prf_comb <- prf_lmc %*% t(m_comb)

f2 <- function(x, y) dist(rbind(x,y))
prf_comb_dist <- sapply(as.list(as.data.frame(prf_comb)), FUN = f2, y = prf_ecc)

plot(prf_comb_dist)
```



